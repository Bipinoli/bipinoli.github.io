<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <title>Memory alignment mystery</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-QWTKZyjpPEjISv5WaRU9OFeRpok6YctnYmDr5pNlyT2bRjXh0JMhjY6hW+ALEwIH" crossorigin="anonymous">
    <link rel="stylesheet" href="/assets/css/style.css">
    <meta name="google-site-verification" content="pmkodQu29Wp0iO4x1qcHEJ6Tg_Xs_MeJfRBRRixXfj4" />
  </head>
  <body>
    <div class="top-banner">
      <div class="top-banner-content">
        <p>Learning trail of <a href="https://www.linkedin.com/in/olibipin/">Bipin Oli</a></p>
        <p><a href="/art">My oil paintings</a></p>
      </div>
    </div>

    <div class="main-container">
      <div class="content">
        <h1>Memory alignment mystery</h1>
<p class="page-date">29 Nov 2025</p>

<div class="page-content">
  
  <div class="content-with-toc">
    <p>While playing with C, I encountered this interesting alignment padding behaviour in <code class="language-plaintext highlighter-rouge">struct</code>.</p>

<p>For <code class="language-plaintext highlighter-rouge">struct</code> as follows:</p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="n">AlignmentCheck</span> <span class="p">{</span>
  <span class="kt">char</span> <span class="n">c</span><span class="p">;</span>
  <span class="kt">double</span> <span class="n">d</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">a</span><span class="p">;</span>
<span class="p">};</span>
</code></pre></div></div>

<p>Here <code class="language-plaintext highlighter-rouge">char</code> takes 1 byte, <code class="language-plaintext highlighter-rouge">double</code> takes 8 bytes, <code class="language-plaintext highlighter-rouge">int</code> takes 4 bytes. However, we need to introduce padding bytes to align the data properly in memory.</p>

<p>I was expecting the compiler to reorder the fields such that data can be aligned while reducing the number of padding. 
However, the compiler didn’t do this even with <code class="language-plaintext highlighter-rouge">-O3</code> optimization enabled, which surprised me.</p>

<p>For context, processors operate on data in units of its word size. For example, 64 bits on a 64-bit CPU. Therefore, data must be properly aligned in memory. For instance, a 64-bit word can hold two 32-bit integers, but only if they are aligned correctly, starting at a memory address that is a multiple of their size. Proper alignment ensures that each data element resides at a memory location that is a multiple of its own size, which allows the CPU to access it efficiently. Improper alignment can cause the CPU to fetch the data multiple times in order to access the complete value. Additionally, the data may be split across cache lines, which can further reduce performance.</p>

<p>So, for our struct above, if we store the fields in the given order (char -&gt; double -&gt; int):</p>
<ul>
  <li>The double must be 8-byte aligned, so we need to introduce 7 bytes of padding between char and double.</li>
  <li>Similarly, if we don’t add any padding after int, the next element in an array of this struct could have its double at a misaligned address. Therefore, we also need 4 bytes of padding at the end.</li>
</ul>

<p>This brings the total size of the struct to 24 bytes.</p>

<p>I was expecting the compiler to reorder the fields automatically, for example, double -&gt; int -&gt; char, which would reduce padding and produce a more compact 16-byte struct. However, that didn’t happen.</p>

<p>After investigating, I found that C strictly enforces the order of struct fields for ABI compatibility and memory-mapped I/O. This means it is up to the programmer to be mindful of alignment.</p>

<p>A common strategy to reduce padding seems to be to order struct fields from largest to smallest, which naturally produces a more compact memory layout. This can be a useful micro-optimization, especially when working with large arrays of such structs, since even a small reduction in padding can lead to more data fetched per memory access or better cache utilization.</p>

<p>If the struct is only being used to serialize data for I/O, padding can be wasteful. Fortunately, I found C compilers provide a way to disable padding using <code class="language-plaintext highlighter-rouge">#pragma pack</code>.</p>

<p>For example:</p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#pragma pack(push, 1)
</span><span class="k">struct</span> <span class="n">AlignmentCheck</span> <span class="p">{</span>
    <span class="kt">char</span> <span class="n">c</span><span class="p">;</span>
    <span class="kt">double</span> <span class="n">d</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">a</span><span class="p">;</span>
<span class="p">};</span>
<span class="cp">#pragma pack(pop)
</span></code></pre></div></div>

<p>This produces a struct of 13 bytes, completely eliminating internal padding. However, for computation, a properly padded struct must be constructed from deserilization.</p>

  </div>
</div>


      </div>
      <div class="sidebar">
        <div class="sidebar">
    <h3>All posts</h3>
    
    
      <p>2025</p>
        <ul>
          
            <li><a href="/2025/11/29/Alignment-mystery.html"  class="current-post" >Memory alignment mystery</a></li>
          
            <li><a href="/2025/11/02/concurrent-quicksort.html" >Concurrent quicksort algorithm with custom thread pool in C++</a></li>
          
        </ul>
    
      <p>2024</p>
        <ul>
          
            <li><a href="/2024/12/18/AOC-day17.html" >Quine in processor</a></li>
          
            <li><a href="/2024/09/19/Dockerized-Verilog-to-FPGA-synthesis-pipeline-copy.html" >Dockerized FPGA synthesis pipeline</a></li>
          
            <li><a href="/2024/09/14/pkg-config.html" >pkg-config</a></li>
          
            <li><a href="/2024/08/01/My-notes-on-Haskell.html" >My notes on Haskell</a></li>
          
            <li><a href="/2024/08/01/Git-bisect.html" >Git bisect</a></li>
          
        </ul>
    
      <p>2020</p>
        <ul>
          
            <li><a href="/2020/01/21/Merkle-tree-in-2-minutes.html" >Essense of Merkle tree</a></li>
          
        </ul>
    
      <p>2018</p>
        <ul>
          
            <li><a href="/2018/04/26/Tic-tac-toe-with-MiniMax-AI.html" >Tic tac toe with minimax</a></li>
          
        </ul>
    
</div>

      </div>
    </div>
  </body>
</html>
