<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <title>My notes on Haskell</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-QWTKZyjpPEjISv5WaRU9OFeRpok6YctnYmDr5pNlyT2bRjXh0JMhjY6hW+ALEwIH" crossorigin="anonymous">
    <link rel="stylesheet" href="/assets/css/style.css">
    <meta name="google-site-verification" content="pmkodQu29Wp0iO4x1qcHEJ6Tg_Xs_MeJfRBRRixXfj4" />
  </head>
  <body>
    <div class="top-banner">
      <p>Learning trail of <a href="https://www.linkedin.com/in/olibipin/">Bipin Oli</a></p>
    </div>

    <div class="main-container">
      <div class="content">
        <h1>My notes on Haskell</h1>
<p class="page-date">01 Aug 2024</p>

<div class="page-content">
  <ul id="toc" class="section-nav">
<li class="toc-entry toc-h4"><a href="#let-and-where">Let and where</a></li>
<li class="toc-entry toc-h4"><a href="#haskell-has-no-loop">Haskell has no loop</a></li>
<li class="toc-entry toc-h4"><a href="#parametric-polymorphism--list-comprehension">Parametric polymorphism &amp; list comprehension</a></li>
<li class="toc-entry toc-h4"><a href="#challenge-graph-traversal">Challenge: graph traversal</a></li>
<li class="toc-entry toc-h4"><a href="#high-order-functions--lambda">High-order functions &amp; lambda</a></li>
<li class="toc-entry toc-h4"><a href="#currying--composition">Currying &amp; composition</a></li>
<li class="toc-entry toc-h4"><a href="#challenge-find-prefixes">Challenge: find prefixes</a></li>
<li class="toc-entry toc-h4"><a href="#challenge-preorder-traversal-of-trie">Challenge: Preorder traversal of Trie</a></li>
<li class="toc-entry toc-h4"><a href="#records">Records</a></li>
<li class="toc-entry toc-h4"><a href="#typeclass-is-like-interface">Typeclass is like interface</a></li>
<li class="toc-entry toc-h4"><a href="#io-action">IO Action</a></li>
<li class="toc-entry toc-h4"><a href="#monad">Monad</a></li>
<li class="toc-entry toc-h4"><a href="#functor-fmap-">Functor: fmap, &lt;$&gt;</a></li>
<li class="toc-entry toc-h4"><a href="#applicative-functor--pure">Applicative Functor: &lt;*&gt;, pure</a></li>
<li class="toc-entry toc-h4"><a href="#challenge-infinite-fibonacci-with-dp">Challenge: Infinite fibonacci with DP</a></li>
<li class="toc-entry toc-h4"><a href="#strictness-thunks-seq-deepseq">Strictness: thunks, seq, deepseq</a></li>
<li class="toc-entry toc-h4"><a href="#gadt">GADT</a></li>
<li class="toc-entry toc-h4"><a href="#haskell-extensions">Haskell Extensions</a>
<ul>
<li class="toc-entry toc-h5"><a href="#type-family">Type Family</a></li>
</ul>
</li>
</ul>
  <div class="content-with-toc">
    <h4 id="let-and-where">Let and where</h4>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>module Main where 

-- let 
diff :: Integer -&gt; Integer -&gt; Integer
diff a b = let firstSmall = a &lt; b 
               difference = a - b
              in 
                if firstSmall then - difference else difference


-- where 
diff2 :: Integer -&gt; Integer -&gt; Integer
diff2 a b = if firstSmall then - difference else difference
           where 
             firstSmall = a &lt; b
             difference = a - b



main :: IO ()
-- main = print (diff 3 2)
main = print (diff 2 3)
</code></pre></div></div>

<h4 id="haskell-has-no-loop">Haskell has no loop</h4>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>-- Recursion and guards
factorial :: Integer -&gt; Integer
factorial n
    | n &lt;= 1 = 1
    | otherwise = n * factorial (n - 1)


-- Tail recursive way
-- Note: tail recursive functions can be replaced by while loop thus avoiding potential stackoverflow
fact :: Integer -&gt; Integer
fact n = accumulator n 1 
        where 
            accumulator n total 
                | n &lt;= 1 = total 
                | otherwise = accumulator (n-1) (n * total)
</code></pre></div></div>

<h4 id="parametric-polymorphism--list-comprehension">Parametric polymorphism &amp; list comprehension</h4>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>-- Cross product of lists with generic datatype
cross :: [a] -&gt; [b] -&gt; [(a, b)]
cross x y = [(i, j) | i &lt;- x, j &lt;- y]


-- Remove duplicates from the list
-- Parametric datatype a with Eq typeclass constraint
existsIn :: (Eq a) =&gt; a -&gt; [a] -&gt; Bool
existsIn _ [] = False 
existsIn a (x:xs) = (a == x) || (a `existsIn` xs)

removeDuplicates :: (Eq a) =&gt; [a] -&gt; [a]
removeDuplicates [] = []
removeDuplicates (x:xs)
    | x `existsIn` xs = removeDuplicates xs
    | otherwise = x : removeDuplicates xs
</code></pre></div></div>

<h4 id="challenge-graph-traversal">Challenge: graph traversal</h4>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>-- Create a function 'hasPath' that determines
-- if a path from one node to another exists in the directed graph.

-- Graph is a list of edges where edge is a pair of nodes which indicates 
-- and existence of path from the first to the second.
-- Eg. in a graph [(1,2), (2,3)], there are directed edges from 1 to 2 and 2 to 3

hasPath :: [(Int, Int)] -&gt; Int -&gt; Int -&gt; Bool
hasPath [] src dest = src == dest
hasPath xs src dest 
    | src == dest = True
    | otherwise = let connectingEdges = [(a,b) | (a,b) &lt;- xs, a /= src]
                  in or [hasPath connectingEdges b dest | (a, b) &lt;- xs, a == src]
</code></pre></div></div>

<h4 id="high-order-functions--lambda">High-order functions &amp; lambda</h4>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>filter (\(x,y) -&gt; x &gt; y) [(1,2), (2,3), (4,2), (2,1)]
map (\x -&gt; -x) [1,2,3]
foldl (\acc elem -&gt; acc + elem) 0 [1,2,3,4,5]
</code></pre></div></div>

<h4 id="currying--composition">Currying &amp; composition</h4>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>adder :: Int -&gt; Int -&gt; Int 
adder x y = x + y

-- composition of partial functions
result = adder 2 ((adder 2 . adder 1) 4)

-- dollar sign syntatic-sugar
result2 = adder 2 $ adder 2 . adder 1 $ 4
</code></pre></div></div>

<h4 id="challenge-find-prefixes">Challenge: find prefixes</h4>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>-- a function that returns all the prefixes of the list
-- eg: FindPrefixes [1,2,3] = [[1], [1,2], [1,2,3]]
findPrefixes :: [a] -&gt; [[a]]
findPrefixes = foldr (\x acc -&gt; [x] : (map (\sublst -&gt; x : sublst) acc)) []
</code></pre></div></div>

<h4 id="challenge-preorder-traversal-of-trie">Challenge: Preorder traversal of Trie</h4>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>module Main where 

data Trie a = Leaf a | Node a [Trie a]

preorderTraversal :: Trie a -&gt; [a]
preorderTraversal (Leaf a) = [a]
preorderTraversal (Node a children) = 
    a : foldl (\acc c -&gt; acc ++ preorderTraversal c) [] children

-- Trie
--   c
--   |-&gt; a
--   |   |-&gt;  r
--   |   |-&gt;  t
--   |-&gt; o
--       |-&gt;  o
--            |-&gt; l  

trie = Node 'c' [
    Node 'a' [
        Leaf 'r',
        Leaf 't'
    ],
    Node 'o' [
        Node 'o' [
            Leaf 'n'
        ]
    ]]

main :: IO ()
main = print $ preorderTraversal trie
</code></pre></div></div>

<h4 id="records">Records</h4>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>module Main where

data Person = Person { name :: String, age :: Int }

greet :: Person -&gt; [Char]
greet (Person name _) = "Hi, " ++ name

main :: IO ()
main = print $ greet Person { name = "Bipin", age = 23}
</code></pre></div></div>

<h4 id="typeclass-is-like-interface">Typeclass is like interface</h4>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>-- declaring typeclass
class Animal a where 
    canWalk :: a -&gt; Bool
    speak :: a -&gt; String

-- instance of typeclass for a type
data Dog = Dog { dogName :: String}
instance Animal Dog where 
    canWalk _ = True
    speak (Dog dogName) = "I am " ++ dogName ++ ". woof!!"

-- deriving typeclass Show (implemented based on type of fields)
data Crow = Crow { birdName :: String }
    deriving (Show)
instance Animal Crow where 
    canWalk _ = False
    speak (Crow birdName) = "I am " ++ birdName ++ ". Caw! Caw!" 

crow = Crow { birdName = "Mr. Crow"}

main :: IO ()
main = print $ show crow ++ " says " ++ speak crow
</code></pre></div></div>

<h4 id="io-action">IO Action</h4>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>-- IO action, not a function as it interacts with environment
-- do -&gt; for sequential step by step work
-- Evaluates to no expression so () type
main :: IO ()
main = do 
    inpt &lt;- getLine
    if inpt /= "exit" then do
        putStrLn $ "input: " ++ inpt
        main
    else 
        return ()
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>printInBetween :: [Int] -&gt; IO ()
printInBetween (x:[]) = return ()
printInBetween (x:y:[]) = do 
    putStrLn $ show x
    if x &lt; y then printInBetween $ (x+1) : [y]
    else return ()

main :: IO ()
main = do 
    putStrLn "Enter two integers separated by space."
    putStrLn "I will give you numbers in between."
    nums &lt;- getLine
    let numbers = map read $ words nums :: [Int]
    printInBetween numbers
</code></pre></div></div>

<h4 id="monad">Monad</h4>
<p>Monad is a box that can hold a value. It has a bind function (»=) that can be used to chain the monads together. When the value exists the bind function take the inner value and returns another monad. Otherwise it returns the fail case and the flow won’t go to the next item in the chain.</p>

<p>This is a very useful pattern to deal with exceptions, asynchronous operation eg. Promise, mutation of environment (IO actions), etc.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>module Main where 

import Control.Applicative
import Control.Monad (liftM, ap)

-- New Monad type
data MyMaybe a = Value a | NoValue
    deriving (Show)

-- This is needed for all monads 
instance Functor MyMaybe where
  fmap = liftM
instance Applicative MyMaybe where
  pure  = return
  (&lt;*&gt;) = ap

-- implementing Monad typeclass 
--    (&gt;&gt;=) is a bind function
instance Monad MyMaybe where 
    (&gt;&gt;=) :: MyMaybe a -&gt; (a -&gt; MyMaybe b) -&gt; MyMaybe b
    ma &gt;&gt;= func = case ma of
                    Value a -&gt; func a
                    NoValue -&gt; NoValue
    return a = Value a

-- example of chaining 
addMonads :: Num a =&gt; MyMaybe a -&gt; MyMaybe a -&gt; MyMaybe a
addMonads ma mb = ma &gt;&gt;= (\a -&gt; mb &gt;&gt;= (\b -&gt; return $ a + b))

-- do notation does the same but more readable
-- if at any point the value is NoValue 
--     the function returns immediately with NoValue
addMonads2 :: Num a =&gt; MyMaybe a -&gt; MyMaybe a -&gt; MyMaybe a
addMonads2 ma mb = do 
    a &lt;- ma
    b &lt;- mb
    return $ a + b

x = Value 12
y = Value 23

main :: IO ()
main = print $ addMonads2 x y
</code></pre></div></div>

<h4 id="functor-fmap-">Functor: fmap, &lt;$&gt;</h4>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>module Main where 

-- functor is a pattern with a function 
-- that maps the internal value without changing the structure
data Tree a = Leaf a | Node a (Tree a) (Tree a)
    deriving (Show)

instance Functor Tree where 
    fmap::(a-&gt;b) -&gt; Tree a -&gt; Tree b
    fmap func (Leaf a) = Leaf $ func a
    fmap func (Node a left right) = 
      Node (func a) (fmap func left) (fmap func right)

tree = Node 1 (Node 2 (Leaf 3) (Node 4 (Leaf 5) (Leaf 6))) (Leaf 7)
treeMapped = fmap (\x -&gt; -x) tree

-- &lt;$&gt; is a symbol for `fmap`
anotherMapped = (*(-10)) &lt;$&gt; tree

main :: IO ()
main = do
    print treeMapped 
    print anotherMapped

-- program output:
Node (-1) (Node (-2) (Leaf (-3)) (Node (-4) (Leaf (-5)) (Leaf (-6)))) (Leaf (-7))
Node (-10) (Node (-20) (Leaf (-30)) (Node (-40) (Leaf (-50)) (Leaf (-60)))) (Leaf (-70))
</code></pre></div></div>

<h4 id="applicative-functor--pure">Applicative Functor: &lt;*&gt;, pure</h4>

<p>Applicative is a typeclass the represents a function inside a container.  It provides a functions <code class="language-plaintext highlighter-rouge">pure</code> and <code class="language-plaintext highlighter-rouge">&lt;*&gt;</code>. <code class="language-plaintext highlighter-rouge">pure</code> takes a function and wraps around the container. <code class="language-plaintext highlighter-rouge">&lt;*&gt;</code> takes a Applicative and a value in a container and produces a container with a function applied to the value.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>module Main where

containerOfComputation:: Maybe (Integer -&gt; Integer)
containerOfComputation = Just (*2)

containerOfValue:: Maybe Integer
containerOfValue = Just 10

main :: IO()
main = print ()

-- program output
ghci&gt; containerOfComputation &lt;*&gt; containerOfValue
Just 20
ghci&gt; 
ghci&gt; Nothing &lt;*&gt; Just 2
Nothing
ghci&gt; Just (*2) &lt;*&gt; Nothing
Nothing
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>module Main where

add1 :: Integer -&gt; Integer -&gt; Integer
add1 x y = x + y

add2 :: Maybe (Integer -&gt; Integer -&gt; Integer)
add2 = Just add1

main :: IO ()
main = do 
    print $ add2 &lt;*&gt; Just 10 &lt;*&gt; Just 20
    -- "pure add" wraps the function in the container
    print $ pure add1 &lt;*&gt; Just 10 &lt;*&gt; Just 20

-- program output
Just 30
Just 30
</code></pre></div></div>
<h4 id="challenge-infinite-fibonacci-with-dp">Challenge: Infinite fibonacci with DP</h4>

<p>Haskell being a lazy language allows infinite data structures.</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>module Main where 

fibo = 0 : 1 : zipWith (+) fibo (tail fibo)

main :: IO ()
main = print $ take 10 fibo
</code></pre></div></div>

<h4 id="strictness-thunks-seq-deepseq">Strictness: thunks, seq, deepseq</h4>

<p>Haskell is a lazy language. It doesn’t execute the expression until it needs to. It keeps track of the unevaluated expressions as graph called thunks. Haskell function doesn’t evaluate the function parameters before applying the function. It creates a new expression (thunk) for the result of the function with the inputs which are other thunks (parameters). This is how the thunk graph is built. Since functions are pure in Haskell, the function expression is evaluated only once and the memoized result is shared. So the dependencies get merged into a single shared thunk thereby the evaluation tree gets converted into a directed graph with shared node. I.e thunk is a computation graph that is yet to be completely evaluated.</p>

<p>However, sometimes the thunk graph can build up and take huge memory and the performance is impacted due to this overhead. In such cases evaluating the thunk early can be desirable.</p>

<p>Haskell has a function called <code class="language-plaintext highlighter-rouge">seq:: a -&gt; b -&gt; b</code>. The behaviour of the function is enforced in Haskell compiler to evaluate <code class="language-plaintext highlighter-rouge">a</code> to <a href="https://wiki.haskell.org/Weak_head_normal_form">weak head normal form</a> before running <code class="language-plaintext highlighter-rouge">b</code>. In other words, <code class="language-plaintext highlighter-rouge">a</code> will be partially evaluated before running b. This provides a way of strictness in Haskell. Many common functions such as <code class="language-plaintext highlighter-rouge">foldl</code> have strict versions (<code class="language-plaintext highlighter-rouge">foldl'</code>) that use <code class="language-plaintext highlighter-rouge">seq</code> internally.</p>

<p>Haskell also provides a way to completely evaluate <code class="language-plaintext highlighter-rouge">a</code> before <code class="language-plaintext highlighter-rouge">b</code> called <code class="language-plaintext highlighter-rouge">deepseq</code>. It is in the module <code class="language-plaintext highlighter-rouge">Control.DeepSeq</code>. Complete evaluation of thunk is needed in situations such as when you are reading a file from the disk in an IO action. You want to get all contents from file, close the file and return contents from the IO action without keeping the unevaluated thunk with file cursor.</p>

<p>It is important to note that Haskell compiler can lose some type information on strict evaluation of thunk. Haskell compiler also does strictness analysis when the <code class="language-plaintext highlighter-rouge">-O</code> flag is set during compilation.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ghci&gt; x = [1..10] :: [Int]
ghci&gt; :sp x
x = _
ghci&gt; seq x ()
()
ghci&gt; :sp x
x = 1 : _
ghci&gt; 
ghci&gt; import Control.DeepSeq (deepseq)
ghci&gt; deepseq x ()
()
ghci&gt; :sp x
x = [1,2,3,4,5,6,7,8,9,10]
ghci&gt; 
</code></pre></div></div>

<h4 id="gadt">GADT</h4>
<p>Generalised Algebraic Datatype (GADT) is a language extension to Haskell. GADT allows a way to provide precise typing to the data constructor.</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>{-# LANGUAGE GADTs #-}
{-# LANGUAGE StandaloneDeriving #-}
module Main where

-- normal algebraic data type
data Expr a = Constant a | Addition (Expr a) (Expr a)

-- Generalized algebraic data type (GADT)
data Expr2 a where 
    Const :: a -&gt; Expr2 a
    Add :: Expr2 Int -&gt; Expr2 Int -&gt; Expr2 Int
    IsZero :: Expr2 Int -&gt; Expr2 Bool

deriving instance Show a =&gt; Show (Expr2 a)

eval :: Expr2 a -&gt; a
eval (Const x)  = x
eval (Add x y) = eval x + eval y
eval (IsZero x) = eval x == 0


main :: IO ()
main = do
    print $ show $ Const 5
    print $ show $ Add (Const 8) (Const 5)
    print $ show $ IsZero (Const 5)
    print $ show $ eval $ Const 5
    print $ show $ eval $ Add (Const 8) (Const 5)
    print $ show $ eval $ IsZero (Const 5)


---- Output
"Const 5"
"Add (Const 8) (Const 5)"
"IsZero (Const 5)"
"5"
"13"
"False"
</code></pre></div></div>

<h4 id="haskell-extensions">Haskell Extensions</h4>
<h5 id="type-family">Type Family</h5>
<p>Type family is similar to a function but it works on types instead of data. It allows us to associate many types with a common interface.</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>type family Bitsize a :: Nat

Explanation:
Bitsize is a type family that takes in a type 'a' and gives us a 'Nat' i.e Natual number type
</code></pre></div></div>

  </div>
</div>


      </div>
      <div class="sidebar">
        <div class="sidebar">
    <h3>All posts</h3>
    
    
      <p>2024</p>
        <ul>
          
            <li><a href="/2024/09/19/Dockerized-Verilog-to-FPGA-synthesis-pipeline.html" >Dockerized FPGA synthesis pipeline</a></li>
          
            <li><a href="/2024/09/14/pkg-config.html" >pkg-config</a></li>
          
            <li><a href="/2024/08/01/My-notes-on-Haskell.html"  class="current-post" >My notes on Haskell</a></li>
          
            <li><a href="/2024/08/01/Git-bisect.html" >Git bisect</a></li>
          
        </ul>
    
      <p>2020</p>
        <ul>
          
            <li><a href="/2020/01/21/Merkle-tree-in-2-minutes.html" >Essense of Merkle tree</a></li>
          
        </ul>
    
      <p>2018</p>
        <ul>
          
            <li><a href="/2018/04/26/Tic-tac-toe-with-MiniMax-AI.html" >Tic tac toe with minimax</a></li>
          
        </ul>
    
</div>

      </div>
    </div>
  </body>
</html>
