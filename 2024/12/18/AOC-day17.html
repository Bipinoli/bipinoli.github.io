<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <title>Quine in processor</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-QWTKZyjpPEjISv5WaRU9OFeRpok6YctnYmDr5pNlyT2bRjXh0JMhjY6hW+ALEwIH" crossorigin="anonymous">
    <link rel="stylesheet" href="/assets/css/style.css">
    <meta name="google-site-verification" content="pmkodQu29Wp0iO4x1qcHEJ6Tg_Xs_MeJfRBRRixXfj4" />
  </head>
  <body>
    <div class="top-banner">
      <div class="top-banner-content">
        <p>Learning trail of <a href="https://www.linkedin.com/in/olibipin/">Bipin Oli</a></p>
        <p><a href="/art">My oil paintings</a></p>
      </div>
    </div>

    <div class="main-container">
      <div class="content">
        <h1>Quine in processor</h1>
<p class="page-date">18 Dec 2024</p>

<div class="page-content">
  <ul id="toc" class="section-nav">
<li class="toc-entry toc-h2"><a href="#part-1">Part 1</a></li>
<li class="toc-entry toc-h2"><a href="#part-2">Part 2</a>
<ul>
<li class="toc-entry toc-h4"><a href="#problem">Problem</a></li>
<li class="toc-entry toc-h4"><a href="#solution">Solution</a></li>
</ul>
</li>
</ul>
  <div class="content-with-toc">
    <p><img src="/assets/images/aoc_day17/aoc.png" alt="image" height="100px" /></p>

<p>I found the problem from <a href="https://adventofcode.com/2024/day/17">advent of code day 17</a> quite interesting.</p>

<h2 id="part-1">Part 1</h2>
<p>Part1 required a simple processor implementation. I modelled that as a <a href="https://en.wikipedia.org/wiki/Mealy_machine">mealy machine</a> in Haskell.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>module Main where

import Data.Bits
import System.Environment

type Register = Integer
type IP = Integer
type State = (Register, Register, Register, IP)
data OpCode = ADV | BXL | BST | JNZ | BXC | OUT | BDV | CDV 
    deriving Show
type Operand = Integer
type Instr = (Integer, Operand)
type Output = [Integer]

toOpCode :: Integer -&gt; OpCode
toOpCode x = case x of 
    0 -&gt; ADV
    1 -&gt; BXL
    2 -&gt; BST
    3 -&gt; JNZ
    4 -&gt; BXC
    5 -&gt; OUT
    6 -&gt; BDV
    7 -&gt; CDV
    _ -&gt; error "impossible"

combo :: Register -&gt; Register -&gt; Register -&gt; Operand -&gt; Operand
combo a b c x = case x of
    4 -&gt; a
    5 -&gt; b
    6 -&gt; c
    _ -&gt; x

mealyMachine :: (State, Instr) -&gt; (State, Output)
mealyMachine (state, instr) = (nextState, output)
    where 
        (a, b, c, ip) = state
        (opcode, operand) = instr
        (nextState, output) = case toOpCode opcode of 
            ADV -&gt; ((na, b, c, ip + 2), [])
                where na = a `div` (2 ^ combo a b c operand) 
            BXL -&gt; ((a, nb, c, ip + 2), [])
                where nb = xor b operand
            BST -&gt; ((a, nb, c, ip + 2), [])
                where nb = mod (combo a b c operand) 8
            JNZ -&gt; ((a, b, c, nip), [])
                where nip = if a == 0 then ip + 2 else operand
            BXC -&gt; ((a, nb, c, ip + 2), [])
                where nb = xor b c
            BDV -&gt; ((a, nb, c, ip + 2), [])
                where nb = a `div` (2 ^ combo a b c operand) 
            CDV -&gt; ((a, b, nc, ip + 2), [])
                where nc = a `div` (2 ^ combo a b c operand) 
            OUT -&gt; ((a, b, c, ip + 2), [value])
                where value = mod (combo a b c operand) 8

toInt :: Integer -&gt; Int
toInt = fromIntegral

run :: [Integer] -&gt; State -&gt; [Integer] -&gt; [Integer]
run program (a, b, c, ip) outs
    | toInt ip &gt;= length program = outs
    | otherwise = allOutpts
        where 
            (nextState, output) = mealyMachine ((a,b,c,ip), (program !! toInt ip, program !! (toInt ip + 1)))
            allOutpts = run program nextState (outs ++ output)
        

program :: [Integer]
program = [2,4,1,1,7,5,1,4,0,3,4,5,5,5,3,0]


main :: IO()
main = do
    args &lt;- getArgs
    let x = read (head args):: Integer
    let initState = (x, 0, 0, 0) :: State
    print $ run program initState []
</code></pre></div></div>

<h2 id="part-2">Part 2</h2>

<h4 id="problem">Problem</h4>

<p>Part 2 asks us to find the value for a register <code class="language-plaintext highlighter-rouge">A</code> such that when we run the program <code class="language-plaintext highlighter-rouge">Program: 2,4,1,1,7,5,1,4,0,3,4,5,5,5,3,0</code> we get exactly the same output as the program itself. Just like <a href="https://en.wikipedia.org/wiki/Quine_(computing)">quine programs</a>.</p>

<p>For example, if we run the following program we get the exact output as <code class="language-plaintext highlighter-rouge">0,3,5,4,3,0</code>:</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Register A: 117440
Register B: 0
Register C: 0

Program: 0,3,5,4,3,0
</code></pre></div></div>

<h4 id="solution">Solution</h4>

<p>Since the number in register A can be arbitrarily large. We can’t just brute force to find the answer. So we need to find some way to reduce the search space.</p>

<p>To get some intuition, I ran the processor multiple times with increasing value of ‘A’.</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>./main 0 = [5]
./main 50 = [1, 3]
./main 100 = [2, 1, 5]
./main 150 = [2, 5, 7]
./main 200 = [1, 5, 6]
./main 250 = [0, 2, 6]
./main 300 = [0, 2, 1]
./main 350 = [1, 4, 0]
./main 400 = [5, 1, 3]
./main 450 = [7, 1, 2]
./main 500 = [6, 3, 2]
./main 550 = [7, 3, 1, 5]
./main 600 = [1, 4, 5, 5]
./main 650 = [6, 5, 6, 5]
./main 700 = [4, 3, 6, 5]
./main 750 = [6, 5, 4, 5]
./main 800 = [5, 2, 1, 5]
./main 850 = [5, 2, 0, 5]
./main 900 = [5, 5, 3, 5]
./main 950 = [4, 3, 3, 5]
./main 1000 = [1, 7, 2, 5]
./main 1050 = [4, 6, 5, 7]
./main 1100 = [3, 5, 5, 7]
./main 1150 = [3, 0, 5, 7]
./main 1200 = [5, 2, 5, 7]
./main 1250 = [3, 5, 2, 7]
./main 1300 = [1, 3, 1, 7]
./main 1350 = [1, 1, 1, 7]
./main 1400 = [1, 0, 1, 7]
./main 1450 = [2, 3, 3, 7]
</code></pre></div></div>

<p>Here we can observe 2 main things:</p>
<ol>
  <li>When running the processor with increasing value of <code class="language-plaintext highlighter-rouge">A</code>, the length of output monotonically increases. So, we can use binary search to find the window where the output has the desired length.</li>
  <li>As we increase <code class="language-plaintext highlighter-rouge">A</code> The values in output changes more frequently in left than at right, which means to see a change in the rightmost output value we will have to wait much further.  So, I start with a big step size and identify the range where the rightmost value appears. Within those windows, I reduce the step size by an order of magnitude and identify the range where the second last value would appear. I do this on an on from right to left.</li>
</ol>

<p>This way we dramatically reduce the search space to find the solution.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>import subprocess

def run_machine(x):
    result = subprocess.run(['./main', f'{x}'], capture_output=True, text=True)
    return [int(i) for i in result.stdout.strip()[1:-1].split(',')]

def binary_search_length(target_len):
    lo = 1
    hi = int(1e22)
    while lo + 1 &lt; hi:
        md = (lo + hi) // 2
        cur_len = len(run_machine(md))
        if cur_len &lt; target_len:
            lo = md
        else:
            hi = md
    return hi


desired_output = [2,4,1,1,7,5,1,4,0,3,4,5,5,5,3,0]

def search_in(lo, hi, step, index):
    print(lo, hi, step, index)
    ans = []
    inside = False
    last_i = lo
    for i in range(lo, hi, step):
        result = run_machine(i)
        if result[index] == desired_output[index]:
            if not inside:
                inside = True
        elif inside:
            ans.append((last_i, i))
            inside = False
        else:
            last_i = i
    if inside:
        ans.append((last_i, hi))
    return ans


def solve():
    lo = binary_search_length(len(desired_output))
    hi = binary_search_length(len(desired_output) + 1)
    step = 1_000_000_000_000

    possibles = [(lo, hi)]
    for i in reversed(range(2, len(desired_output))):
        print(i, possibles, step)
        new_possibles = []
        for (l, h) in possibles:
            new_possibles.extend(search_in(l, h, step, i))
        possibles = new_possibles
        step //=10
    print(i, possibles, step)

possibles = solve()

for  (l, h) in possibles:
    print(l, h)
    for i in range(l, h):
        result = run_machine(i)
        if all([a == b for (a,b) in zip(desired_output, result)]):
            print(f"answer found: {i}")
            exit(0)
            break
</code></pre></div></div>


  </div>
</div>


      </div>
      <div class="sidebar">
        <div class="sidebar">
    <h3>All posts</h3>
    
    
      <p>2025</p>
        <ul>
          
            <li><a href="/2025/11/02/concurrent-quicksort.html" >Concurrent quicksort algorithm with custom thread pool in C++</a></li>
          
        </ul>
    
      <p>2024</p>
        <ul>
          
            <li><a href="/2024/12/18/AOC-day17.html"  class="current-post" >Quine in processor</a></li>
          
            <li><a href="/2024/09/19/Dockerized-Verilog-to-FPGA-synthesis-pipeline-copy.html" >Dockerized FPGA synthesis pipeline</a></li>
          
            <li><a href="/2024/09/14/pkg-config.html" >pkg-config</a></li>
          
            <li><a href="/2024/08/01/My-notes-on-Haskell.html" >My notes on Haskell</a></li>
          
            <li><a href="/2024/08/01/Git-bisect.html" >Git bisect</a></li>
          
        </ul>
    
      <p>2020</p>
        <ul>
          
            <li><a href="/2020/01/21/Merkle-tree-in-2-minutes.html" >Essense of Merkle tree</a></li>
          
        </ul>
    
      <p>2018</p>
        <ul>
          
            <li><a href="/2018/04/26/Tic-tac-toe-with-MiniMax-AI.html" >Tic tac toe with minimax</a></li>
          
        </ul>
    
</div>

      </div>
    </div>
  </body>
</html>
