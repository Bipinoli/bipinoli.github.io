<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.10.0">Jekyll</generator><link href="/feed.xml" rel="self" type="application/atom+xml" /><link href="/" rel="alternate" type="text/html" /><updated>2024-12-19T07:00:31-06:00</updated><id>/feed.xml</id><title type="html">Bipin Oli</title><subtitle>Write an awesome description for your new site here. You can edit this line in _config.yml. It will appear in your document head meta (for Google search results) and in your feed.xml site description.</subtitle><entry><title type="html">Quine in processor</title><link href="/2024/12/18/AOC-day17.html" rel="alternate" type="text/html" title="Quine in processor" /><published>2024-12-18T00:00:00-06:00</published><updated>2024-12-18T00:00:00-06:00</updated><id>/2024/12/18/AOC-day17</id><content type="html" xml:base="/2024/12/18/AOC-day17.html"><![CDATA[<p><img src="/assets/images/aoc_day17/aoc.png" alt="image" height="100px" /></p>

<p>I found the problem from <a href="https://adventofcode.com/2024/day/17">advent of code day 17</a> quite interesting.</p>

<h2 id="part-1">Part 1</h2>
<p>Part1 required a simple processor implementation. I modelled that as a <a href="https://en.wikipedia.org/wiki/Mealy_machine">mealy machine</a> in Haskell.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>module Main where

import Data.Bits
import System.Environment

type Register = Integer
type IP = Integer
type State = (Register, Register, Register, IP)
data OpCode = ADV | BXL | BST | JNZ | BXC | OUT | BDV | CDV 
    deriving Show
type Operand = Integer
type Instr = (Integer, Operand)
type Output = [Integer]

toOpCode :: Integer -&gt; OpCode
toOpCode x = case x of 
    0 -&gt; ADV
    1 -&gt; BXL
    2 -&gt; BST
    3 -&gt; JNZ
    4 -&gt; BXC
    5 -&gt; OUT
    6 -&gt; BDV
    7 -&gt; CDV
    _ -&gt; error "impossible"

combo :: Register -&gt; Register -&gt; Register -&gt; Operand -&gt; Operand
combo a b c x = case x of
    4 -&gt; a
    5 -&gt; b
    6 -&gt; c
    _ -&gt; x

mealyMachine :: (State, Instr) -&gt; (State, Output)
mealyMachine (state, instr) = (nextState, output)
    where 
        (a, b, c, ip) = state
        (opcode, operand) = instr
        (nextState, output) = case toOpCode opcode of 
            ADV -&gt; ((na, b, c, ip + 2), [])
                where na = a `div` (2 ^ combo a b c operand) 
            BXL -&gt; ((a, nb, c, ip + 2), [])
                where nb = xor b operand
            BST -&gt; ((a, nb, c, ip + 2), [])
                where nb = mod (combo a b c operand) 8
            JNZ -&gt; ((a, b, c, nip), [])
                where nip = if a == 0 then ip + 2 else operand
            BXC -&gt; ((a, nb, c, ip + 2), [])
                where nb = xor b c
            BDV -&gt; ((a, nb, c, ip + 2), [])
                where nb = a `div` (2 ^ combo a b c operand) 
            CDV -&gt; ((a, b, nc, ip + 2), [])
                where nc = a `div` (2 ^ combo a b c operand) 
            OUT -&gt; ((a, b, c, ip + 2), [value])
                where value = mod (combo a b c operand) 8

toInt :: Integer -&gt; Int
toInt = fromIntegral

run :: [Integer] -&gt; State -&gt; [Integer] -&gt; [Integer]
run program (a, b, c, ip) outs
    | toInt ip &gt;= length program = outs
    | otherwise = allOutpts
        where 
            (nextState, output) = mealyMachine ((a,b,c,ip), (program !! toInt ip, program !! (toInt ip + 1)))
            allOutpts = run program nextState (outs ++ output)
        

program :: [Integer]
program = [2,4,1,1,7,5,1,4,0,3,4,5,5,5,3,0]


main :: IO()
main = do
    args &lt;- getArgs
    let x = read (head args):: Integer
    let initState = (x, 0, 0, 0) :: State
    print $ run program initState []
</code></pre></div></div>

<h2 id="part-2">Part 2</h2>

<h4 id="problem">Problem</h4>

<p>Part 2 asks us to find the value for a register <code class="language-plaintext highlighter-rouge">A</code> such that when we run the program <code class="language-plaintext highlighter-rouge">Program: 2,4,1,1,7,5,1,4,0,3,4,5,5,5,3,0</code> we get exactly the same output as the program itself. Just like <a href="https://en.wikipedia.org/wiki/Quine_(computing)">quine programs</a>.</p>

<p>For example, if we run the following program we get the exact output as <code class="language-plaintext highlighter-rouge">0,3,5,4,3,0</code>:</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Register A: 117440
Register B: 0
Register C: 0

Program: 0,3,5,4,3,0
</code></pre></div></div>

<h4 id="solution">Solution</h4>

<p>Since the number in register A can be arbitrarily large. We can’t just brute force to find the answer. So we need to find some way to reduce the search space.</p>

<p>To get some intuition, I ran the processor multiple times with increasing value of ‘A’.</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>./main 0 = [5]
./main 50 = [1, 3]
./main 100 = [2, 1, 5]
./main 150 = [2, 5, 7]
./main 200 = [1, 5, 6]
./main 250 = [0, 2, 6]
./main 300 = [0, 2, 1]
./main 350 = [1, 4, 0]
./main 400 = [5, 1, 3]
./main 450 = [7, 1, 2]
./main 500 = [6, 3, 2]
./main 550 = [7, 3, 1, 5]
./main 600 = [1, 4, 5, 5]
./main 650 = [6, 5, 6, 5]
./main 700 = [4, 3, 6, 5]
./main 750 = [6, 5, 4, 5]
./main 800 = [5, 2, 1, 5]
./main 850 = [5, 2, 0, 5]
./main 900 = [5, 5, 3, 5]
./main 950 = [4, 3, 3, 5]
./main 1000 = [1, 7, 2, 5]
./main 1050 = [4, 6, 5, 7]
./main 1100 = [3, 5, 5, 7]
./main 1150 = [3, 0, 5, 7]
./main 1200 = [5, 2, 5, 7]
./main 1250 = [3, 5, 2, 7]
./main 1300 = [1, 3, 1, 7]
./main 1350 = [1, 1, 1, 7]
./main 1400 = [1, 0, 1, 7]
./main 1450 = [2, 3, 3, 7]
</code></pre></div></div>

<p>Here we can observe 2 main things:</p>
<ol>
  <li>When running the processor with increasing value of <code class="language-plaintext highlighter-rouge">A</code>, the length of output monotonically increases. So, we can use binary search to find the window where the output has the desired length.</li>
  <li>As we increase <code class="language-plaintext highlighter-rouge">A</code> The values in output changes more frequently in left than at right, which means to see a change in the rightmost output value we will have to wait much further.  So, I start with a big step size and identify the range where the rightmost value appears. Within those windows, I reduce the step size by an order of magnitude and identify the range where the second last value would appear. I do this on an on from right to left.</li>
</ol>

<p>This way we dramatically reduce the search space to find the solution.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>import subprocess

def run_machine(x):
    result = subprocess.run(['./main', f'{x}'], capture_output=True, text=True)
    return [int(i) for i in result.stdout.strip()[1:-1].split(',')]

def binary_search_length(target_len):
    lo = 1
    hi = int(1e22)
    while lo + 1 &lt; hi:
        md = (lo + hi) // 2
        cur_len = len(run_machine(md))
        if cur_len &lt; target_len:
            lo = md
        else:
            hi = md
    return hi


desired_output = [2,4,1,1,7,5,1,4,0,3,4,5,5,5,3,0]

def search_in(lo, hi, step, index):
    print(lo, hi, step, index)
    ans = []
    inside = False
    last_i = lo
    for i in range(lo, hi, step):
        result = run_machine(i)
        if result[index] == desired_output[index]:
            if not inside:
                inside = True
        elif inside:
            ans.append((last_i, i))
            inside = False
        else:
            last_i = i
    if inside:
        ans.append((last_i, hi))
    return ans


def solve():
    lo = binary_search_length(len(desired_output))
    hi = binary_search_length(len(desired_output) + 1)
    step = 1_000_000_000_000

    possibles = [(lo, hi)]
    for i in reversed(range(2, len(desired_output))):
        print(i, possibles, step)
        new_possibles = []
        for (l, h) in possibles:
            new_possibles.extend(search_in(l, h, step, i))
        possibles = new_possibles
        step //=10
    print(i, possibles, step)

possibles = solve()

for  (l, h) in possibles:
    print(l, h)
    for i in range(l, h):
        result = run_machine(i)
        if all([a == b for (a,b) in zip(desired_output, result)]):
            print(f"answer found: {i}")
            exit(0)
            break
</code></pre></div></div>]]></content><author><name></name></author><summary type="html"><![CDATA[]]></summary></entry><entry><title type="html">Dockerized FPGA synthesis pipeline</title><link href="/2024/09/19/Dockerized-Verilog-to-FPGA-synthesis-pipeline-copy.html" rel="alternate" type="text/html" title="Dockerized FPGA synthesis pipeline" /><published>2024-09-19T00:00:00-05:00</published><updated>2024-09-19T00:00:00-05:00</updated><id>/2024/09/19/Dockerized-Verilog-to-FPGA-synthesis-pipeline%20copy</id><content type="html" xml:base="/2024/09/19/Dockerized-Verilog-to-FPGA-synthesis-pipeline-copy.html"><![CDATA[<p><img src="/assets/images/verilog2Fpga/fpga.png" alt="image" height="200px" /></p>

<p>I have been playing with Haskell and lately the <a href="https://clash-lang.org/Clash">Clash hardware compiler</a>. Clash transpiles the functional hardware description written in Haskell to the standard HDLs such as Verilog. To be able to run such verilog code in an FPGA, a bitstream needs to be generated to program the FPGA. This post talks about a dockerized pipeline called <a href="https://github.com/Bipinoli/verilog2fpga">Verilog2Fpga</a> to do that.</p>

<h3 id="synthesis-pipeline">Synthesis pipeline</h3>
<p><a href="https://github.com/Bipinoli/verilog2fpga">Verilog2Fpga</a> uses the existing open-source synthesis tools. It currently programs the iCE40HX1K-BLINK-EVN FPGA as that’s the one I happen to have.</p>

<ol>
  <li><a href="https://github.com/cliffordwolf/yosys">yosys</a> - to synthesize circult netlist from the HDL</li>
  <li><a href="https://github.com/YosysHQ/nextpnr">nextpnr</a> - for placing and routing of circuit components for the FPGA</li>
  <li><a href="https://github.com/cliffordwolf/icestorm/">icestorm</a> - to create a bitstream file with <a href="https://github.com/cliffordwolf/icestorm/">icepack</a> for Lattice iCE40 FPGA</li>
  <li><a href="https://github.com/reactive-systems/icedude">icedude</a> - to program the iCE40 evaluation board with the produced bitstream</li>
</ol>

<h3 id="how-to-use">How to use?</h3>

<h4 id="linux">Linux</h4>
<ol>
  <li>Connect the FPGA via usb</li>
  <li>Setup docker container with <code class="language-plaintext highlighter-rouge">./setup_container.sh</code></li>
  <li>Run <code class="language-plaintext highlighter-rouge">./synthesize.sh</code> with a path to your verilog files (.v, .pcf) as an argument. <br />
 Eg: <code class="language-plaintext highlighter-rouge">./synthesize.sh example_verilog</code></li>
</ol>

<h4 id="macos--windows">macOS / Windows</h4>
<p>On macOS and Windows, the docker runs within a separate VM, so unlike linux, it can’t natively access the usb device. There are many ways this could be handled. Such as:</p>
<ul>
  <li>Configuring the VM where docker runs</li>
  <li>Using tools like <a href="https://linux.die.net/man/1/socat">socat</a> to forward usb data via TCP socket</li>
</ul>

<h5 id="how-i-configured-for-macos">How I configured for macOS</h5>
<p>I use Mac so I faced this issue myself. I chose to install a separate linux VM (debian) with virtualbox instead of configuring with the above mentioned methods, mainly for ease. This is how I configured VM</p>

<h6 id="1-identify-the-usb-device">1. Identify the usb device</h6>
<ul>
  <li>I ran <code class="language-plaintext highlighter-rouge">ioreg -p IOUSB</code> in macOS which gave me the list of connected usb devices</li>
  <li>To identify the acutal name of the device, I disconnected the FPGA and ran the command again. The device which disappeared from the list is sure to be the the FPGA device</li>
</ul>

<p><img src="/assets/images/verilog2Fpga/list_of_usb.png" alt="image" height="200px" /></p>

<h6 id="2-configure-the-vm-to-access-the-identified-usb-device">2. Configure the VM to access the identified USB device</h6>
<p>With the device name known, I put it in the usb device filters of VM setting. Alternatively, I could have passed through all the usb devices but this gave me more confidence.</p>

<p><img src="/assets/images/verilog2Fpga/configure_vm.png" alt="image" height="300px" /></p>

<p>When the VM was running, I quickly ran <code class="language-plaintext highlighter-rouge">lsusb</code> to verify if it can access the usb device.</p>

<h5 id="running">Running</h5>
<p>After installing docker in the VM. I simply did:</p>
<ol>
  <li><code class="language-plaintext highlighter-rouge">./setup_container.sh</code></li>
  <li><code class="language-plaintext highlighter-rouge">./synthesize.sh example_verilog</code></li>
</ol>

<p>and that was it.</p>]]></content><author><name></name></author><summary type="html"><![CDATA[]]></summary></entry><entry><title type="html">pkg-config</title><link href="/2024/09/14/pkg-config.html" rel="alternate" type="text/html" title="pkg-config" /><published>2024-09-14T00:00:00-05:00</published><updated>2024-09-14T00:00:00-05:00</updated><id>/2024/09/14/pkg-config</id><content type="html" xml:base="/2024/09/14/pkg-config.html"><![CDATA[<p><code class="language-plaintext highlighter-rouge">pkg-config</code> is a tool that originated in Linux to view the meta information about installed libraries. It can be used to know things like:</p>
<ul>
  <li>include path of header files</li>
  <li>link path of library files</li>
  <li>version of library</li>
  <li>etc.</li>
</ul>

<p>When a library is built or installed, usually a <code class="language-plaintext highlighter-rouge">.pc</code> meta file is produced. <code class="language-plaintext highlighter-rouge">.pc</code> file contains all meta information such as link path, etc. For <code class="language-plaintext highlighter-rouge">pkg-config</code> to work with the library, the <code class="language-plaintext highlighter-rouge">.pc</code> file must be placed in the correct search location (<code class="language-plaintext highlighter-rouge">PKG_CONFIG_PATH</code> environment variable).</p>

<h2 id="example-use">Example use</h2>
<p>Say I want to use <code class="language-plaintext highlighter-rouge">libpng</code> to work with png images. I install <code class="language-plaintext highlighter-rouge">libpng</code> via say homebrew and now want to use it in my project as a library. How can I do that?</p>

<ol>
  <li>
    <p>First let’s see what version of <code class="language-plaintext highlighter-rouge">libpng</code> do I have <br />
<code class="language-plaintext highlighter-rouge">$ pkg-config --modversion libpng</code> <br />
<code class="language-plaintext highlighter-rouge">1.6.43</code></p>
  </li>
  <li>
    <p>Ok good. Where can I find the header files for <code class="language-plaintext highlighter-rouge">libpng</code> <br />
<code class="language-plaintext highlighter-rouge">$ pkg-config --cflags libpng</code> <br />
<code class="language-plaintext highlighter-rouge">-I/opt/local/include/libpng16 -I/opt/local/include</code></p>
  </li>
  <li>
    <p>Nice. What about the path of libraries to link? <br />
<code class="language-plaintext highlighter-rouge">$ pkg-config --libs libpng</code> <br />
<code class="language-plaintext highlighter-rouge">-L/opt/local/lib -lpng16</code></p>
  </li>
</ol>

<p>With these information I can easily use the library with my project like: <br />
<code class="language-plaintext highlighter-rouge">gcc pngViewr.c -o pngViewr -I/opt/local/include/libpng16 -I/opt/local/include -L/opt/local/lib -lpng16</code></p>

<p>or even better: <br />
<code class="language-plaintext highlighter-rouge">gcc pngViewr.c -o pngViewr $(pkg-config --libs -cflags libpng)</code></p>]]></content><author><name></name></author><summary type="html"><![CDATA[pkg-config is a tool that originated in Linux to view the meta information about installed libraries. It can be used to know things like: include path of header files link path of library files version of library etc.]]></summary></entry><entry><title type="html">My notes on Haskell</title><link href="/2024/08/01/My-notes-on-Haskell.html" rel="alternate" type="text/html" title="My notes on Haskell" /><published>2024-08-01T00:00:00-05:00</published><updated>2024-08-01T00:00:00-05:00</updated><id>/2024/08/01/My-notes-on-Haskell</id><content type="html" xml:base="/2024/08/01/My-notes-on-Haskell.html"><![CDATA[<h4 id="let-and-where">Let and where</h4>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>module Main where 

-- let 
diff :: Integer -&gt; Integer -&gt; Integer
diff a b = let firstSmall = a &lt; b 
               difference = a - b
              in 
                if firstSmall then - difference else difference


-- where 
diff2 :: Integer -&gt; Integer -&gt; Integer
diff2 a b = if firstSmall then - difference else difference
           where 
             firstSmall = a &lt; b
             difference = a - b



main :: IO ()
-- main = print (diff 3 2)
main = print (diff 2 3)
</code></pre></div></div>

<h4 id="haskell-has-no-loop">Haskell has no loop</h4>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>-- Recursion and guards
factorial :: Integer -&gt; Integer
factorial n
    | n &lt;= 1 = 1
    | otherwise = n * factorial (n - 1)


-- Tail recursive way
-- Note: tail recursive functions can be replaced by while loop thus avoiding potential stackoverflow
fact :: Integer -&gt; Integer
fact n = accumulator n 1 
        where 
            accumulator n total 
                | n &lt;= 1 = total 
                | otherwise = accumulator (n-1) (n * total)
</code></pre></div></div>

<h4 id="parametric-polymorphism--list-comprehension">Parametric polymorphism &amp; list comprehension</h4>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>-- Cross product of lists with generic datatype
cross :: [a] -&gt; [b] -&gt; [(a, b)]
cross x y = [(i, j) | i &lt;- x, j &lt;- y]


-- Remove duplicates from the list
-- Parametric datatype a with Eq typeclass constraint
existsIn :: (Eq a) =&gt; a -&gt; [a] -&gt; Bool
existsIn _ [] = False 
existsIn a (x:xs) = (a == x) || (a `existsIn` xs)

removeDuplicates :: (Eq a) =&gt; [a] -&gt; [a]
removeDuplicates [] = []
removeDuplicates (x:xs)
    | x `existsIn` xs = removeDuplicates xs
    | otherwise = x : removeDuplicates xs
</code></pre></div></div>

<h4 id="challenge-graph-traversal">Challenge: graph traversal</h4>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>-- Create a function 'hasPath' that determines
-- if a path from one node to another exists in the directed graph.

-- Graph is a list of edges where edge is a pair of nodes which indicates 
-- and existence of path from the first to the second.
-- Eg. in a graph [(1,2), (2,3)], there are directed edges from 1 to 2 and 2 to 3

hasPath :: [(Int, Int)] -&gt; Int -&gt; Int -&gt; Bool
hasPath [] src dest = src == dest
hasPath xs src dest 
    | src == dest = True
    | otherwise = let connectingEdges = [(a,b) | (a,b) &lt;- xs, a /= src]
                  in or [hasPath connectingEdges b dest | (a, b) &lt;- xs, a == src]
</code></pre></div></div>

<h4 id="high-order-functions--lambda">High-order functions &amp; lambda</h4>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>filter (\(x,y) -&gt; x &gt; y) [(1,2), (2,3), (4,2), (2,1)]
map (\x -&gt; -x) [1,2,3]
foldl (\acc elem -&gt; acc + elem) 0 [1,2,3,4,5]
</code></pre></div></div>

<h4 id="currying--composition">Currying &amp; composition</h4>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>adder :: Int -&gt; Int -&gt; Int 
adder x y = x + y

-- composition of partial functions
result = adder 2 ((adder 2 . adder 1) 4)

-- dollar sign syntatic-sugar
result2 = adder 2 $ adder 2 . adder 1 $ 4
</code></pre></div></div>

<h4 id="challenge-find-prefixes">Challenge: find prefixes</h4>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>-- a function that returns all the prefixes of the list
-- eg: FindPrefixes [1,2,3] = [[1], [1,2], [1,2,3]]
findPrefixes :: [a] -&gt; [[a]]
findPrefixes = foldr (\x acc -&gt; [x] : (map (\sublst -&gt; x : sublst) acc)) []
</code></pre></div></div>

<h4 id="challenge-preorder-traversal-of-trie">Challenge: Preorder traversal of Trie</h4>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>module Main where 

data Trie a = Leaf a | Node a [Trie a]

preorderTraversal :: Trie a -&gt; [a]
preorderTraversal (Leaf a) = [a]
preorderTraversal (Node a children) = 
    a : foldl (\acc c -&gt; acc ++ preorderTraversal c) [] children

-- Trie
--   c
--   |-&gt; a
--   |   |-&gt;  r
--   |   |-&gt;  t
--   |-&gt; o
--       |-&gt;  o
--            |-&gt; l  

trie = Node 'c' [
    Node 'a' [
        Leaf 'r',
        Leaf 't'
    ],
    Node 'o' [
        Node 'o' [
            Leaf 'n'
        ]
    ]]

main :: IO ()
main = print $ preorderTraversal trie
</code></pre></div></div>

<h4 id="records">Records</h4>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>module Main where

data Person = Person { name :: String, age :: Int }

greet :: Person -&gt; [Char]
greet (Person name _) = "Hi, " ++ name

main :: IO ()
main = print $ greet Person { name = "Bipin", age = 23}
</code></pre></div></div>

<h4 id="typeclass-is-like-interface">Typeclass is like interface</h4>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>-- declaring typeclass
class Animal a where 
    canWalk :: a -&gt; Bool
    speak :: a -&gt; String

-- instance of typeclass for a type
data Dog = Dog { dogName :: String}
instance Animal Dog where 
    canWalk _ = True
    speak (Dog dogName) = "I am " ++ dogName ++ ". woof!!"

-- deriving typeclass Show (implemented based on type of fields)
data Crow = Crow { birdName :: String }
    deriving (Show)
instance Animal Crow where 
    canWalk _ = False
    speak (Crow birdName) = "I am " ++ birdName ++ ". Caw! Caw!" 

crow = Crow { birdName = "Mr. Crow"}

main :: IO ()
main = print $ show crow ++ " says " ++ speak crow
</code></pre></div></div>

<h4 id="io-action">IO Action</h4>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>-- IO action, not a function as it interacts with environment
-- do -&gt; for sequential step by step work
-- Evaluates to no expression so () type
main :: IO ()
main = do 
    inpt &lt;- getLine
    if inpt /= "exit" then do
        putStrLn $ "input: " ++ inpt
        main
    else 
        return ()
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>printInBetween :: [Int] -&gt; IO ()
printInBetween (x:[]) = return ()
printInBetween (x:y:[]) = do 
    putStrLn $ show x
    if x &lt; y then printInBetween $ (x+1) : [y]
    else return ()

main :: IO ()
main = do 
    putStrLn "Enter two integers separated by space."
    putStrLn "I will give you numbers in between."
    nums &lt;- getLine
    let numbers = map read $ words nums :: [Int]
    printInBetween numbers
</code></pre></div></div>

<h4 id="monad">Monad</h4>
<p>Monad is a box that can hold a value. It has a bind function (»=) that can be used to chain the monads together. When the value exists the bind function take the inner value and returns another monad. Otherwise it returns the fail case and the flow won’t go to the next item in the chain.</p>

<p>This is a very useful pattern to deal with exceptions, asynchronous operation eg. Promise, mutation of environment (IO actions), etc.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>module Main where 

import Control.Applicative
import Control.Monad (liftM, ap)

-- New Monad type
data MyMaybe a = Value a | NoValue
    deriving (Show)

-- This is needed for all monads 
instance Functor MyMaybe where
  fmap = liftM
instance Applicative MyMaybe where
  pure  = return
  (&lt;*&gt;) = ap

-- implementing Monad typeclass 
--    (&gt;&gt;=) is a bind function
instance Monad MyMaybe where 
    (&gt;&gt;=) :: MyMaybe a -&gt; (a -&gt; MyMaybe b) -&gt; MyMaybe b
    ma &gt;&gt;= func = case ma of
                    Value a -&gt; func a
                    NoValue -&gt; NoValue
    return a = Value a

-- example of chaining 
addMonads :: Num a =&gt; MyMaybe a -&gt; MyMaybe a -&gt; MyMaybe a
addMonads ma mb = ma &gt;&gt;= (\a -&gt; mb &gt;&gt;= (\b -&gt; return $ a + b))

-- do notation does the same but more readable
-- if at any point the value is NoValue 
--     the function returns immediately with NoValue
addMonads2 :: Num a =&gt; MyMaybe a -&gt; MyMaybe a -&gt; MyMaybe a
addMonads2 ma mb = do 
    a &lt;- ma
    b &lt;- mb
    return $ a + b

x = Value 12
y = Value 23

main :: IO ()
main = print $ addMonads2 x y
</code></pre></div></div>

<h4 id="functor-fmap-">Functor: fmap, &lt;$&gt;</h4>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>module Main where 

-- functor is a pattern with a function 
-- that maps the internal value without changing the structure
data Tree a = Leaf a | Node a (Tree a) (Tree a)
    deriving (Show)

instance Functor Tree where 
    fmap::(a-&gt;b) -&gt; Tree a -&gt; Tree b
    fmap func (Leaf a) = Leaf $ func a
    fmap func (Node a left right) = 
      Node (func a) (fmap func left) (fmap func right)

tree = Node 1 (Node 2 (Leaf 3) (Node 4 (Leaf 5) (Leaf 6))) (Leaf 7)
treeMapped = fmap (\x -&gt; -x) tree

-- &lt;$&gt; is a symbol for `fmap`
anotherMapped = (*(-10)) &lt;$&gt; tree

main :: IO ()
main = do
    print treeMapped 
    print anotherMapped

-- program output:
Node (-1) (Node (-2) (Leaf (-3)) (Node (-4) (Leaf (-5)) (Leaf (-6)))) (Leaf (-7))
Node (-10) (Node (-20) (Leaf (-30)) (Node (-40) (Leaf (-50)) (Leaf (-60)))) (Leaf (-70))
</code></pre></div></div>

<h4 id="applicative-functor--pure">Applicative Functor: &lt;*&gt;, pure</h4>

<p>Applicative is a typeclass the represents a function inside a container.  It provides a functions <code class="language-plaintext highlighter-rouge">pure</code> and <code class="language-plaintext highlighter-rouge">&lt;*&gt;</code>. <code class="language-plaintext highlighter-rouge">pure</code> takes a function and wraps around the container. <code class="language-plaintext highlighter-rouge">&lt;*&gt;</code> takes a Applicative and a value in a container and produces a container with a function applied to the value.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>module Main where

containerOfComputation:: Maybe (Integer -&gt; Integer)
containerOfComputation = Just (*2)

containerOfValue:: Maybe Integer
containerOfValue = Just 10

main :: IO()
main = print ()

-- program output
ghci&gt; containerOfComputation &lt;*&gt; containerOfValue
Just 20
ghci&gt; 
ghci&gt; Nothing &lt;*&gt; Just 2
Nothing
ghci&gt; Just (*2) &lt;*&gt; Nothing
Nothing
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>module Main where

add1 :: Integer -&gt; Integer -&gt; Integer
add1 x y = x + y

add2 :: Maybe (Integer -&gt; Integer -&gt; Integer)
add2 = Just add1

main :: IO ()
main = do 
    print $ add2 &lt;*&gt; Just 10 &lt;*&gt; Just 20
    -- "pure add" wraps the function in the container
    print $ pure add1 &lt;*&gt; Just 10 &lt;*&gt; Just 20

-- program output
Just 30
Just 30
</code></pre></div></div>
<h4 id="challenge-infinite-fibonacci-with-dp">Challenge: Infinite fibonacci with DP</h4>

<p>Haskell being a lazy language allows infinite data structures.</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>module Main where 

fibo = 0 : 1 : zipWith (+) fibo (tail fibo)

main :: IO ()
main = print $ take 10 fibo
</code></pre></div></div>

<h4 id="strictness-thunks-seq-deepseq">Strictness: thunks, seq, deepseq</h4>

<p>Haskell is a lazy language. It doesn’t execute the expression until it needs to. It keeps track of the unevaluated expressions as graph called thunks. Haskell function doesn’t evaluate the function parameters before applying the function. It creates a new expression (thunk) for the result of the function with the inputs which are other thunks (parameters). This is how the thunk graph is built. Since functions are pure in Haskell, the function expression is evaluated only once and the memoized result is shared. So the dependencies get merged into a single shared thunk thereby the evaluation tree gets converted into a directed graph with shared node. I.e thunk is a computation graph that is yet to be completely evaluated.</p>

<p>However, sometimes the thunk graph can build up and take huge memory and the performance is impacted due to this overhead. In such cases evaluating the thunk early can be desirable.</p>

<p>Haskell has a function called <code class="language-plaintext highlighter-rouge">seq:: a -&gt; b -&gt; b</code>. The behaviour of the function is enforced in Haskell compiler to evaluate <code class="language-plaintext highlighter-rouge">a</code> to <a href="https://wiki.haskell.org/Weak_head_normal_form">weak head normal form</a> before running <code class="language-plaintext highlighter-rouge">b</code>. In other words, <code class="language-plaintext highlighter-rouge">a</code> will be partially evaluated before running b. This provides a way of strictness in Haskell. Many common functions such as <code class="language-plaintext highlighter-rouge">foldl</code> have strict versions (<code class="language-plaintext highlighter-rouge">foldl'</code>) that use <code class="language-plaintext highlighter-rouge">seq</code> internally.</p>

<p>Haskell also provides a way to completely evaluate <code class="language-plaintext highlighter-rouge">a</code> before <code class="language-plaintext highlighter-rouge">b</code> called <code class="language-plaintext highlighter-rouge">deepseq</code>. It is in the module <code class="language-plaintext highlighter-rouge">Control.DeepSeq</code>. Complete evaluation of thunk is needed in situations such as when you are reading a file from the disk in an IO action. You want to get all contents from file, close the file and return contents from the IO action without keeping the unevaluated thunk with file cursor.</p>

<p>It is important to note that Haskell compiler can lose some type information on strict evaluation of thunk. Haskell compiler also does strictness analysis when the <code class="language-plaintext highlighter-rouge">-O</code> flag is set during compilation.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ghci&gt; x = [1..10] :: [Int]
ghci&gt; :sp x
x = _
ghci&gt; seq x ()
()
ghci&gt; :sp x
x = 1 : _
ghci&gt; 
ghci&gt; import Control.DeepSeq (deepseq)
ghci&gt; deepseq x ()
()
ghci&gt; :sp x
x = [1,2,3,4,5,6,7,8,9,10]
ghci&gt; 
</code></pre></div></div>

<h4 id="gadt">GADT</h4>
<p>Generalised Algebraic Datatype (GADT) is a language extension to Haskell. GADT allows a way to provide precise typing to the data constructor.</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>{-# LANGUAGE GADTs #-}
{-# LANGUAGE StandaloneDeriving #-}
module Main where

-- normal algebraic data type
data Expr a = Constant a | Addition (Expr a) (Expr a)

-- Generalized algebraic data type (GADT)
data Expr2 a where 
    Const :: a -&gt; Expr2 a
    Add :: Expr2 Int -&gt; Expr2 Int -&gt; Expr2 Int
    IsZero :: Expr2 Int -&gt; Expr2 Bool

deriving instance Show a =&gt; Show (Expr2 a)

eval :: Expr2 a -&gt; a
eval (Const x)  = x
eval (Add x y) = eval x + eval y
eval (IsZero x) = eval x == 0


main :: IO ()
main = do
    print $ show $ Const 5
    print $ show $ Add (Const 8) (Const 5)
    print $ show $ IsZero (Const 5)
    print $ show $ eval $ Const 5
    print $ show $ eval $ Add (Const 8) (Const 5)
    print $ show $ eval $ IsZero (Const 5)


---- Output
"Const 5"
"Add (Const 8) (Const 5)"
"IsZero (Const 5)"
"5"
"13"
"False"
</code></pre></div></div>

<h4 id="haskell-extensions">Haskell Extensions</h4>
<h5 id="type-family">Type Family</h5>
<p>Type family is similar to a function but it works on types instead of data. It allows us to associate many types with a common interface.</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>type family Bitsize a :: Nat

Explanation:
Bitsize is a type family that takes in a type 'a' and gives us a 'Nat' i.e Natual number type
</code></pre></div></div>]]></content><author><name></name></author><summary type="html"><![CDATA[Let and where ``` module Main where]]></summary></entry><entry><title type="html">Git bisect</title><link href="/2024/08/01/Git-bisect.html" rel="alternate" type="text/html" title="Git bisect" /><published>2024-08-01T00:00:00-05:00</published><updated>2024-08-01T00:00:00-05:00</updated><id>/2024/08/01/Git-bisect</id><content type="html" xml:base="/2024/08/01/Git-bisect.html"><![CDATA[<p><a href="https://git-scm.com/docs/git-bisect">Git bisect</a> is a tool that does binary search in the git history between commits to locate the actual commit where the change of interest happen. This “change of interest” is usually a bug, so <code class="language-plaintext highlighter-rouge">git bisect bad</code> command is used to indicate observation of it.</p>

<h3 id="how-to-use">How to use?</h3>
<p>Basically we do manual binary search.</p>
<ul>
  <li>do <code class="language-plaintext highlighter-rouge">git bisect start</code> to start git bisect</li>
  <li>do <code class="language-plaintext highlighter-rouge">git bisect bad</code> to mark current commit as bad</li>
  <li>do <code class="language-plaintext highlighter-rouge">git bisect good &lt;&lt;commit_hash&gt;&gt;</code> to mark good commit</li>
  <li>do <code class="language-plaintext highlighter-rouge">git bisect</code> to bisect to a mid commit</li>
</ul>

<p>Before marking current commit as good or bad we check the “change of interest”.
This could be manual inspection, test run, performance logs, anything.</p>

<h2 id="when-to-use">When to use?</h2>
<p>Anytime you want to locate the actual commit that caused the change. The affect of change must be reproducible.</p>
<ul>
  <li>Where was the bug introduced?</li>
  <li>What exactly improved this performance?</li>
  <li>What change cause the test to start failing?</li>
  <li>etc. etc.</li>
</ul>

<h3 id="related">Related</h3>
<p><a href="https://research.swtch.com/bisect">Russ cox’s blog on “Hash-Based Bisect Debugging in Compilers and Runtimes”</a></p>]]></content><author><name></name></author><summary type="html"><![CDATA[Git bisect is a tool that does binary search in the git history between commits to locate the actual commit where the change of interest happen. This “change of interest” is usually a bug, so git bisect bad command is used to indicate observation of it.]]></summary></entry><entry><title type="html">Essense of Merkle tree</title><link href="/2020/01/21/Merkle-tree-in-2-minutes.html" rel="alternate" type="text/html" title="Essense of Merkle tree" /><published>2020-01-21T00:00:00-06:00</published><updated>2020-01-21T00:00:00-06:00</updated><id>/2020/01/21/Merkle-tree-in-2-minutes</id><content type="html" xml:base="/2020/01/21/Merkle-tree-in-2-minutes.html"><![CDATA[<p>To construct a Merkel Tree, we basically hash the individual data blocks and hash those hashes and hash those hashes and so on. Forming a tree structure.</p>

<p><img src="/assets/images/merkle_tree/merkle.png" alt="image" height="500px" /></p>

<p>While hashing the hashes say <strong>H1</strong>, <strong>H2</strong>, <strong>H3</strong> we append those hashes to get a single string <strong>H1 + H2 + H3</strong> and hash that individual string to get a new hash <strong>H123</strong>.</p>

<p>Merkle Tree is mainly used to efficiently verify the integrity of the data.</p>

<p>Let’s take a closer look at the diagram above: hash <strong>H12</strong> has basically the summary of <strong>data1</strong> and <strong>data2</strong>. Even if a single bit in <strong>data1</strong> or <strong>data2</strong> changes it will be reflected in <strong>H12</strong>. Thus, if we are comparing two Merkle trees and found that <strong>H12</strong> is the same in both. Then it guarantees that <strong>data1</strong> and <strong>data2</strong> haven’t been changed.</p>

<p>This way root of the tree holds the summary of all its children and we only need to compare the root node to detect the differences.</p>

<p>In order to identify the data nodes that have been changed. We can compare the root hashes. If that is different, we can compare the hashes of its children and so on.</p>

<p>Say, we were transferring the data from one server node to another. And in the meantime, <strong>data3</strong> got updated in the source.</p>

<p><img src="/assets/images/merkle_tree/merkle_update.png" alt="image" height="500px" /></p>

<p>Now on comparing the Merkle Tree of received data to its source. We can see that:</p>

<p><strong>H1234</strong> is different so there are changes. <strong>H12</strong> is the same so its sub-tree is clean. Following the hashes that are different, we go from <strong>H1234</strong> to <strong>H34</strong> to <strong>H3</strong> to <strong>data3</strong> basically identifying the changed data.</p>

<p>Merkel Tree has been useful in many use cases. DynamoDB uses Merkel Tree for consistent hashing. Git uses Merkel Tree to keep git history. It is also used in internet file sharing. Knowing the root hash from a trusted source we can combine only those data pieces that produce the same root hash allowing us to filter the tempered and infected data pieces.</p>

<p><em>Originally <a href="https://medium.com/@bipinoli90/merkle-tree-in-2-mins-simplified-1577d15b4850">published on Medium</a></em></p>]]></content><author><name></name></author><summary type="html"><![CDATA[To construct a Merkel Tree, we basically hash the individual data blocks and hash those hashes and hash those hashes and so on. Forming a tree structure.]]></summary></entry><entry><title type="html">Tic tac toe with minimax</title><link href="/2018/04/26/Tic-tac-toe-with-MiniMax-AI.html" rel="alternate" type="text/html" title="Tic tac toe with minimax" /><published>2018-04-26T00:00:00-05:00</published><updated>2018-04-26T00:00:00-05:00</updated><id>/2018/04/26/Tic-tac-toe-with-MiniMax-AI</id><content type="html" xml:base="/2018/04/26/Tic-tac-toe-with-MiniMax-AI.html"><![CDATA[<p><img src="/assets/images/tic_tac_toe/tic_tac_toe.png" alt="image" height="500px" /></p>

<p>With nothing particular to do, this semester break seemed pretty dull. I was lying in the bed bored and lazy. Suddenly, I had an urge to make a simple game. I decided on Tic Tac Toe as it seemed easy and started laying out my plan. Within few hours, I had some rudimentary game in front of me.</p>

<p>Github link: <a href="https://github.com/Bipinoli/Tic-Tac-Toe">here</a></p>

<p><em>Note: Later I made an android game from it in Godot and published the game on Google play store. The image above is the banner image from there. The game is no longer available in the store</em></p>

<p><em>Originally <a href="https://medium.com/@bipinoli90/tic-tac-toe-with-minimax-ai-102d19a8eb7b">published on Medium</a></em></p>]]></content><author><name></name></author><summary type="html"><![CDATA[]]></summary></entry></feed>