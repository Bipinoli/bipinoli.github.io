<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.10.0">Jekyll</generator><link href="/feed.xml" rel="self" type="application/atom+xml" /><link href="/" rel="alternate" type="text/html" /><updated>2025-11-29T17:43:35-06:00</updated><id>/feed.xml</id><title type="html">Bipin Oli</title><subtitle>Write an awesome description for your new site here. You can edit this line in _config.yml. It will appear in your document head meta (for Google search results) and in your feed.xml site description.</subtitle><entry><title type="html">Memory alignment mystery</title><link href="/2025/11/29/Alignment-mystery.html" rel="alternate" type="text/html" title="Memory alignment mystery" /><published>2025-11-29T00:00:00-06:00</published><updated>2025-11-29T00:00:00-06:00</updated><id>/2025/11/29/Alignment-mystery</id><content type="html" xml:base="/2025/11/29/Alignment-mystery.html"><![CDATA[<p>While playing with C, I encountered this interesting alignment padding behaviour in <code class="language-plaintext highlighter-rouge">struct</code>.</p>

<p>For <code class="language-plaintext highlighter-rouge">struct</code> as follows:</p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="n">AlignmentCheck</span> <span class="p">{</span>
  <span class="kt">char</span> <span class="n">c</span><span class="p">;</span>
  <span class="kt">double</span> <span class="n">d</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">a</span><span class="p">;</span>
<span class="p">};</span>
</code></pre></div></div>

<p>Here <code class="language-plaintext highlighter-rouge">char</code> takes 1 byte, <code class="language-plaintext highlighter-rouge">double</code> takes 8 bytes, <code class="language-plaintext highlighter-rouge">int</code> takes 4 bytes. However, we need to introduce padding bytes to align the data properly in memory.</p>

<p>I was expecting the compiler to reorder the fields such that data can be aligned while reducing the number of padding. 
However, the compiler didn’t do this even with <code class="language-plaintext highlighter-rouge">-O3</code> optimization enabled, which surprised me.</p>

<p>For context, processors operate on data in units of its word size. For example, 64 bits on a 64-bit CPU. Therefore, data must be properly aligned in memory. For instance, a 64-bit word can hold two 32-bit integers, but only if they are aligned correctly, starting at a memory address that is a multiple of their size. Proper alignment ensures that each data element resides at a memory location that is a multiple of its own size, which allows the CPU to access it efficiently. Improper alignment can cause the CPU to fetch the data multiple times in order to access the complete value. Additionally, the data may be split across cache lines, which can further reduce performance.</p>

<p>So, for our struct above, if we store the fields in the given order (char -&gt; double -&gt; int):</p>
<ul>
  <li>The double must be 8-byte aligned, so we need to introduce 7 bytes of padding between char and double.</li>
  <li>Similarly, if we don’t add any padding after int, the next element in an array of this struct could have its double at a misaligned address. Therefore, we also need 4 bytes of padding at the end.</li>
</ul>

<p>This brings the total size of the struct to 24 bytes.</p>

<p>I was expecting the compiler to reorder the fields automatically, for example, double -&gt; int -&gt; char, which would reduce padding and produce a more compact 16-byte struct. However, that didn’t happen.</p>

<p>After investigating, I found that C strictly enforces the order of struct fields for ABI compatibility and memory-mapped I/O. This means it is up to the programmer to be mindful of alignment.</p>

<p>A common strategy to reduce padding seems to be to order struct fields from largest to smallest, which naturally produces a more compact memory layout. This can be a useful micro-optimization, especially when working with large arrays of such structs, since even a small reduction in padding can lead to more data fetched per memory access or better cache utilization.</p>

<p>If the struct is only being used to serialize data for I/O, padding can be wasteful. Fortunately, I found C compilers provide a way to disable padding using <code class="language-plaintext highlighter-rouge">#pragma pack</code>.</p>

<p>For example:</p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#pragma pack(push, 1)
</span><span class="k">struct</span> <span class="n">AlignmentCheck</span> <span class="p">{</span>
    <span class="kt">char</span> <span class="n">c</span><span class="p">;</span>
    <span class="kt">double</span> <span class="n">d</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">a</span><span class="p">;</span>
<span class="p">};</span>
<span class="cp">#pragma pack(pop)
</span></code></pre></div></div>

<p>This produces a struct of 13 bytes, completely eliminating internal padding. However, for computation, a properly padded struct must be constructed from deserilization.</p>]]></content><author><name></name></author><summary type="html"><![CDATA[While playing with C, I encountered this interesting alignment padding behaviour in struct.]]></summary></entry><entry><title type="html">Concurrent quicksort algorithm with custom thread pool in C++</title><link href="/2025/11/02/concurrent-quicksort.html" rel="alternate" type="text/html" title="Concurrent quicksort algorithm with custom thread pool in C++" /><published>2025-11-02T00:00:00-05:00</published><updated>2025-11-02T00:00:00-05:00</updated><id>/2025/11/02/concurrent-quicksort</id><content type="html" xml:base="/2025/11/02/concurrent-quicksort.html"><![CDATA[<p>While reading <i>C++ Concurrency in Action</i>, I got the idea of implementing a concurrent version of the quicksort algorithm. My plan was to create a pool of worker threads and use them to concurrently execute the recursive subtasks of the sort. <a href="https://github.com/Bipinoli/performance-focused-programming/tree/89f16df1ff8111fe852ec630e2ab2c3fbefda52d/quiksort_workers_multi_threaded">This is my implementation on GitHub</a>. In this post, I want to document the idea and share my general thought process.</p>

<h4 id="step-1-sequential-quicksort-algorithm">Step 1: Sequential quicksort algorithm</h4>
<p><a href="https://github.com/Bipinoli/performance-focused-programming/tree/89f16df1ff8111fe852ec630e2ab2c3fbefda52d/quiksort_workers_multi_threaded/sequential.hpp">Link to the sequential implementation</a></p>

<p>The quicksort algorithm sorts numbers using the divide-and-conquer strategy. The idea is to choose a number in the array as a pivot and arrange the elements so that the numbers less than the pivot are on the left and the greater ones are on the right, thereby fixing the pivot’s final position in the array. After this, the subarrays on the left and right can follow the same process.</p>

<p>I realized I had never actually implemented quicksort before, and I was too proud to look up any examples, so it took me some time to figure out a good in-place solution for rearranging the numbers around the pivot. After <a href="https://github.com/Bipinoli/performance-focused-programming/tree/89f16df1ff8111fe852ec630e2ab2c3fbefda52d/quiksort_workers_multi_threaded/test.hpp">testing</a> the implementation with randomly generated arrays, I was satisfied with the results and moved on to the concurrent version.</p>

<h4 id="step-2-concurrent-quicksort-algorithm">Step 2: Concurrent quicksort algorithm</h4>
<p><a href="https://github.com/Bipinoli/performance-focused-programming/tree/89f16df1ff8111fe852ec630e2ab2c3fbefda52d/quiksort_workers_multi_threaded/concurrent.hpp">Link to the concurrent implementation</a></p>

<p>The quicksort algorithm has a recursive structure like this:</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>sort: [n,n,n,n,n,n,n]
- choose pivot p &amp; arrange numbers around it [s,s,s,p,p,b,b]
- sort smaller [s,s,s]
- sort bigger [b,b]
</code></pre></div></div>
<p>This shows the <a href="https://en.wikipedia.org/wiki/Tail_call">tail-recursive</a> nature of the algorithm. After the arrangement step, the positions of the pivot elements are final. Therefore, we don’t need to know the results of the sub-tasks.</p>

<h5 id="worker-system">Worker system</h5>
<p>So, the idea is quite simple. Let’s set up a pool of worker threads. Each worker will fetch a task from the task queue. A task contains a reference to an array, along with the start and end indices to sort in place. The worker selects a pivot and arranges the numbers around it. After that, it creates the necessary sub-tasks and submits them back to the task queue, where they can be picked up by any available worker. In this way, multiple workers can concurrently sort different parts of the array. Since there’s no interdependency, we can even apply this to multiple arrays at once, i.e. a batch of arrays.</p>

<h5 id="knowing-when-sort-has-finished">Knowing when sort has finished</h5>
<p>It’s important to know when the sorting process has completed. Since each worker only handles a portion of the array, it doesn’t have enough information on its own to determine whether all sub-tasks are finished. To manage this, we maintain a count of all in-progress sub-tasks. Whenever a task is subdivided, the worker increments an atomic counter to reflect the creation of new sub-tasks. When there are no further sub-tasks to divide and the pivoting is complete, the worker decrements the in-progress counter and notifies the main thread. The main thread waits for this notification and checks the counter to determine whether all sub-tasks have finished.</p>

<p>Note that this counter-based scheme works because we don’t need to maintain a stack of sub-task statuses, thanks to the tail-recursive nature of the algorithm.</p>

<h4 id="step-3-validation">Step 3: Validation</h4>
<p>I wanted to roughly validate that the concurrent implementation was working. To do this, I created a sufficiently large batch of arrays so that the thread overhead would be justified, and I could observe whether the concurrent version actually took less time. I generated a random batch of sort tasks and measured the execution time for each.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>boli@Bipins-MBP quick_sort % ./build/main
main(62428,0x109480600) malloc: nano zone abandoned due to inability to preallocate reserved vm space.
Sequential quicksort test passed!
Concurrent quicksort test passed!
--------------------------------
Performance comparison between sequential quicksort and concurrent quicksort:
Sorting batch #0 with 5357214 numbers in total
Sorting completed by sequential quicksort in 17243 ms
Sorting completed by concurrent quicksort with 7 workers in 5434 ms
Sorting batch #1 with 4751498 numbers in total
Sorting completed by sequential quicksort in 19370 ms
Sorting completed by concurrent quicksort with 7 workers in 4616 ms
Sorting batch #2 with 5283119 numbers in total
Sorting completed by sequential quicksort in 17046 ms
Sorting completed by concurrent quicksort with 7 workers in 4736 ms
Sorting batch #3 with 5415888 numbers in total
Sorting completed by sequential quicksort in 17375 ms
Sorting completed by concurrent quicksort with 7 workers in 4728 ms
boli@Bipins-MBP quick_sort %
</code></pre></div></div>

<p>It would be nice to have some observability metrics to see exactly how busy the workers were with actual compute tasks. The total execution time seems excessively large for what the program does. However, the important thing is that concurrency does appear to bring performance benefits, which is what I wanted to confirm.</p>

<p>In the future, I’d like to explore Linux’s <i>perf</i> or try some eBPF-based tools for deeper analysis. The <a href="https://perfwiki.github.io/main/">perf wiki guide</a> is already on my reading list, and it would be great to revisit here once I’ve gone through it.</p>

<p>For now, though, it’s time to continue with the other chapters of the book.</p>

<p>Thank you for reading. Adios!</p>]]></content><author><name></name></author><summary type="html"><![CDATA[While reading C++ Concurrency in Action, I got the idea of implementing a concurrent version of the quicksort algorithm. My plan was to create a pool of worker threads and use them to concurrently execute the recursive subtasks of the sort. This is my implementation on GitHub. In this post, I want to document the idea and share my general thought process.]]></summary></entry><entry><title type="html">Quine in processor</title><link href="/2024/12/18/AOC-day17.html" rel="alternate" type="text/html" title="Quine in processor" /><published>2024-12-18T00:00:00-06:00</published><updated>2024-12-18T00:00:00-06:00</updated><id>/2024/12/18/AOC-day17</id><content type="html" xml:base="/2024/12/18/AOC-day17.html"><![CDATA[<p><img src="/assets/images/aoc_day17/aoc.png" alt="image" height="100px" /></p>

<p>I found the problem from <a href="https://adventofcode.com/2024/day/17">advent of code day 17</a> quite interesting.</p>

<h2 id="part-1">Part 1</h2>
<p>Part1 required a simple processor implementation. I modelled that as a <a href="https://en.wikipedia.org/wiki/Mealy_machine">mealy machine</a> in Haskell.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>module Main where

import Data.Bits
import System.Environment

type Register = Integer
type IP = Integer
type State = (Register, Register, Register, IP)
data OpCode = ADV | BXL | BST | JNZ | BXC | OUT | BDV | CDV 
    deriving Show
type Operand = Integer
type Instr = (Integer, Operand)
type Output = [Integer]

toOpCode :: Integer -&gt; OpCode
toOpCode x = case x of 
    0 -&gt; ADV
    1 -&gt; BXL
    2 -&gt; BST
    3 -&gt; JNZ
    4 -&gt; BXC
    5 -&gt; OUT
    6 -&gt; BDV
    7 -&gt; CDV
    _ -&gt; error "impossible"

combo :: Register -&gt; Register -&gt; Register -&gt; Operand -&gt; Operand
combo a b c x = case x of
    4 -&gt; a
    5 -&gt; b
    6 -&gt; c
    _ -&gt; x

mealyMachine :: (State, Instr) -&gt; (State, Output)
mealyMachine (state, instr) = (nextState, output)
    where 
        (a, b, c, ip) = state
        (opcode, operand) = instr
        (nextState, output) = case toOpCode opcode of 
            ADV -&gt; ((na, b, c, ip + 2), [])
                where na = a `div` (2 ^ combo a b c operand) 
            BXL -&gt; ((a, nb, c, ip + 2), [])
                where nb = xor b operand
            BST -&gt; ((a, nb, c, ip + 2), [])
                where nb = mod (combo a b c operand) 8
            JNZ -&gt; ((a, b, c, nip), [])
                where nip = if a == 0 then ip + 2 else operand
            BXC -&gt; ((a, nb, c, ip + 2), [])
                where nb = xor b c
            BDV -&gt; ((a, nb, c, ip + 2), [])
                where nb = a `div` (2 ^ combo a b c operand) 
            CDV -&gt; ((a, b, nc, ip + 2), [])
                where nc = a `div` (2 ^ combo a b c operand) 
            OUT -&gt; ((a, b, c, ip + 2), [value])
                where value = mod (combo a b c operand) 8

toInt :: Integer -&gt; Int
toInt = fromIntegral

run :: [Integer] -&gt; State -&gt; [Integer] -&gt; [Integer]
run program (a, b, c, ip) outs
    | toInt ip &gt;= length program = outs
    | otherwise = allOutpts
        where 
            (nextState, output) = mealyMachine ((a,b,c,ip), (program !! toInt ip, program !! (toInt ip + 1)))
            allOutpts = run program nextState (outs ++ output)
        

program :: [Integer]
program = [2,4,1,1,7,5,1,4,0,3,4,5,5,5,3,0]


main :: IO()
main = do
    args &lt;- getArgs
    let x = read (head args):: Integer
    let initState = (x, 0, 0, 0) :: State
    print $ run program initState []
</code></pre></div></div>

<h2 id="part-2">Part 2</h2>

<h4 id="problem">Problem</h4>

<p>Part 2 asks us to find the value for a register <code class="language-plaintext highlighter-rouge">A</code> such that when we run the program <code class="language-plaintext highlighter-rouge">Program: 2,4,1,1,7,5,1,4,0,3,4,5,5,5,3,0</code> we get exactly the same output as the program itself. Just like <a href="https://en.wikipedia.org/wiki/Quine_(computing)">quine programs</a>.</p>

<p>For example, if we run the following program we get the exact output as <code class="language-plaintext highlighter-rouge">0,3,5,4,3,0</code>:</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Register A: 117440
Register B: 0
Register C: 0

Program: 0,3,5,4,3,0
</code></pre></div></div>

<h4 id="solution">Solution</h4>

<p>Since the number in register A can be arbitrarily large. We can’t just brute force to find the answer. So we need to find some way to reduce the search space.</p>

<p>To get some intuition, I ran the processor multiple times with increasing value of ‘A’.</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>./main 0 = [5]
./main 50 = [1, 3]
./main 100 = [2, 1, 5]
./main 150 = [2, 5, 7]
./main 200 = [1, 5, 6]
./main 250 = [0, 2, 6]
./main 300 = [0, 2, 1]
./main 350 = [1, 4, 0]
./main 400 = [5, 1, 3]
./main 450 = [7, 1, 2]
./main 500 = [6, 3, 2]
./main 550 = [7, 3, 1, 5]
./main 600 = [1, 4, 5, 5]
./main 650 = [6, 5, 6, 5]
./main 700 = [4, 3, 6, 5]
./main 750 = [6, 5, 4, 5]
./main 800 = [5, 2, 1, 5]
./main 850 = [5, 2, 0, 5]
./main 900 = [5, 5, 3, 5]
./main 950 = [4, 3, 3, 5]
./main 1000 = [1, 7, 2, 5]
./main 1050 = [4, 6, 5, 7]
./main 1100 = [3, 5, 5, 7]
./main 1150 = [3, 0, 5, 7]
./main 1200 = [5, 2, 5, 7]
./main 1250 = [3, 5, 2, 7]
./main 1300 = [1, 3, 1, 7]
./main 1350 = [1, 1, 1, 7]
./main 1400 = [1, 0, 1, 7]
./main 1450 = [2, 3, 3, 7]
</code></pre></div></div>

<p>Here we can observe 2 main things:</p>
<ol>
  <li>When running the processor with increasing value of <code class="language-plaintext highlighter-rouge">A</code>, the length of output monotonically increases. So, we can use binary search to find the window where the output has the desired length.</li>
  <li>As we increase <code class="language-plaintext highlighter-rouge">A</code> The values in output changes more frequently in left than at right, which means to see a change in the rightmost output value we will have to wait much further.  So, I start with a big step size and identify the range where the rightmost value appears. Within those windows, I reduce the step size by an order of magnitude and identify the range where the second last value would appear. I do this on an on from right to left.</li>
</ol>

<p>This way we dramatically reduce the search space to find the solution.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>import subprocess

def run_machine(x):
    result = subprocess.run(['./main', f'{x}'], capture_output=True, text=True)
    return [int(i) for i in result.stdout.strip()[1:-1].split(',')]

def binary_search_length(target_len):
    lo = 1
    hi = int(1e22)
    while lo + 1 &lt; hi:
        md = (lo + hi) // 2
        cur_len = len(run_machine(md))
        if cur_len &lt; target_len:
            lo = md
        else:
            hi = md
    return hi


desired_output = [2,4,1,1,7,5,1,4,0,3,4,5,5,5,3,0]

def search_in(lo, hi, step, index):
    print(lo, hi, step, index)
    ans = []
    inside = False
    last_i = lo
    for i in range(lo, hi, step):
        result = run_machine(i)
        if result[index] == desired_output[index]:
            if not inside:
                inside = True
        elif inside:
            ans.append((last_i, i))
            inside = False
        else:
            last_i = i
    if inside:
        ans.append((last_i, hi))
    return ans


def solve():
    lo = binary_search_length(len(desired_output))
    hi = binary_search_length(len(desired_output) + 1)
    step = 1_000_000_000_000

    possibles = [(lo, hi)]
    for i in reversed(range(2, len(desired_output))):
        print(i, possibles, step)
        new_possibles = []
        for (l, h) in possibles:
            new_possibles.extend(search_in(l, h, step, i))
        possibles = new_possibles
        step //=10
    print(i, possibles, step)

possibles = solve()

for  (l, h) in possibles:
    print(l, h)
    for i in range(l, h):
        result = run_machine(i)
        if all([a == b for (a,b) in zip(desired_output, result)]):
            print(f"answer found: {i}")
            exit(0)
            break
</code></pre></div></div>]]></content><author><name></name></author><summary type="html"><![CDATA[]]></summary></entry><entry><title type="html">Dockerized FPGA synthesis pipeline</title><link href="/2024/09/19/Dockerized-Verilog-to-FPGA-synthesis-pipeline-copy.html" rel="alternate" type="text/html" title="Dockerized FPGA synthesis pipeline" /><published>2024-09-19T00:00:00-05:00</published><updated>2024-09-19T00:00:00-05:00</updated><id>/2024/09/19/Dockerized-Verilog-to-FPGA-synthesis-pipeline%20copy</id><content type="html" xml:base="/2024/09/19/Dockerized-Verilog-to-FPGA-synthesis-pipeline-copy.html"><![CDATA[<p><img src="/assets/images/verilog2Fpga/fpga.png" alt="image" height="200px" /></p>

<p>I have been playing with Haskell and lately the <a href="https://clash-lang.org/Clash">Clash hardware compiler</a>. Clash transpiles the functional hardware description written in Haskell to the standard HDLs such as Verilog. To be able to run such verilog code in an FPGA, a bitstream needs to be generated to program the FPGA. This post talks about a dockerized pipeline called <a href="https://github.com/Bipinoli/verilog2fpga">Verilog2Fpga</a> to do that.</p>

<h3 id="synthesis-pipeline">Synthesis pipeline</h3>
<p><a href="https://github.com/Bipinoli/verilog2fpga">Verilog2Fpga</a> uses the existing open-source synthesis tools. It currently programs the iCE40HX1K-BLINK-EVN FPGA as that’s the one I happen to have.</p>

<ol>
  <li><a href="https://github.com/cliffordwolf/yosys">yosys</a> - to synthesize circult netlist from the HDL</li>
  <li><a href="https://github.com/YosysHQ/nextpnr">nextpnr</a> - for placing and routing of circuit components for the FPGA</li>
  <li><a href="https://github.com/cliffordwolf/icestorm/">icestorm</a> - to create a bitstream file with <a href="https://github.com/cliffordwolf/icestorm/">icepack</a> for Lattice iCE40 FPGA</li>
  <li><a href="https://github.com/reactive-systems/icedude">icedude</a> - to program the iCE40 evaluation board with the produced bitstream</li>
</ol>

<h3 id="how-to-use">How to use?</h3>

<h4 id="linux">Linux</h4>
<ol>
  <li>Connect the FPGA via usb</li>
  <li>Setup docker container with <code class="language-plaintext highlighter-rouge">./setup_container.sh</code></li>
  <li>Run <code class="language-plaintext highlighter-rouge">./synthesize.sh</code> with a path to your verilog files (.v, .pcf) as an argument. <br />
 Eg: <code class="language-plaintext highlighter-rouge">./synthesize.sh example_verilog</code></li>
</ol>

<h4 id="macos--windows">macOS / Windows</h4>
<p>On macOS and Windows, the docker runs within a separate VM, so unlike linux, it can’t natively access the usb device. There are many ways this could be handled. Such as:</p>
<ul>
  <li>Configuring the VM where docker runs</li>
  <li>Using tools like <a href="https://linux.die.net/man/1/socat">socat</a> to forward usb data via TCP socket</li>
</ul>

<h5 id="how-i-configured-for-macos">How I configured for macOS</h5>
<p>I use Mac so I faced this issue myself. I chose to install a separate linux VM (debian) with virtualbox instead of configuring with the above mentioned methods, mainly for ease. This is how I configured VM</p>

<h6 id="1-identify-the-usb-device">1. Identify the usb device</h6>
<ul>
  <li>I ran <code class="language-plaintext highlighter-rouge">ioreg -p IOUSB</code> in macOS which gave me the list of connected usb devices</li>
  <li>To identify the acutal name of the device, I disconnected the FPGA and ran the command again. The device which disappeared from the list is sure to be the the FPGA device</li>
</ul>

<p><img src="/assets/images/verilog2Fpga/list_of_usb.png" alt="image" height="200px" /></p>

<h6 id="2-configure-the-vm-to-access-the-identified-usb-device">2. Configure the VM to access the identified USB device</h6>
<p>With the device name known, I put it in the usb device filters of VM setting. Alternatively, I could have passed through all the usb devices but this gave me more confidence.</p>

<p><img src="/assets/images/verilog2Fpga/configure_vm.png" alt="image" height="300px" /></p>

<p>When the VM was running, I quickly ran <code class="language-plaintext highlighter-rouge">lsusb</code> to verify if it can access the usb device.</p>

<h5 id="running">Running</h5>
<p>After installing docker in the VM. I simply did:</p>
<ol>
  <li><code class="language-plaintext highlighter-rouge">./setup_container.sh</code></li>
  <li><code class="language-plaintext highlighter-rouge">./synthesize.sh example_verilog</code></li>
</ol>

<p>and that was it.</p>]]></content><author><name></name></author><summary type="html"><![CDATA[]]></summary></entry><entry><title type="html">pkg-config</title><link href="/2024/09/14/pkg-config.html" rel="alternate" type="text/html" title="pkg-config" /><published>2024-09-14T00:00:00-05:00</published><updated>2024-09-14T00:00:00-05:00</updated><id>/2024/09/14/pkg-config</id><content type="html" xml:base="/2024/09/14/pkg-config.html"><![CDATA[<p><code class="language-plaintext highlighter-rouge">pkg-config</code> is a tool that originated in Linux to view the meta information about installed libraries. It can be used to know things like:</p>
<ul>
  <li>include path of header files</li>
  <li>link path of library files</li>
  <li>version of library</li>
  <li>etc.</li>
</ul>

<p>When a library is built or installed, usually a <code class="language-plaintext highlighter-rouge">.pc</code> meta file is produced. <code class="language-plaintext highlighter-rouge">.pc</code> file contains all meta information such as link path, etc. For <code class="language-plaintext highlighter-rouge">pkg-config</code> to work with the library, the <code class="language-plaintext highlighter-rouge">.pc</code> file must be placed in the correct search location (<code class="language-plaintext highlighter-rouge">PKG_CONFIG_PATH</code> environment variable).</p>

<h2 id="example-use">Example use</h2>
<p>Say I want to use <code class="language-plaintext highlighter-rouge">libpng</code> to work with png images. I install <code class="language-plaintext highlighter-rouge">libpng</code> via say homebrew and now want to use it in my project as a library. How can I do that?</p>

<ol>
  <li>
    <p>First let’s see what version of <code class="language-plaintext highlighter-rouge">libpng</code> do I have <br />
<code class="language-plaintext highlighter-rouge">$ pkg-config --modversion libpng</code> <br />
<code class="language-plaintext highlighter-rouge">1.6.43</code></p>
  </li>
  <li>
    <p>Ok good. Where can I find the header files for <code class="language-plaintext highlighter-rouge">libpng</code> <br />
<code class="language-plaintext highlighter-rouge">$ pkg-config --cflags libpng</code> <br />
<code class="language-plaintext highlighter-rouge">-I/opt/local/include/libpng16 -I/opt/local/include</code></p>
  </li>
  <li>
    <p>Nice. What about the path of libraries to link? <br />
<code class="language-plaintext highlighter-rouge">$ pkg-config --libs libpng</code> <br />
<code class="language-plaintext highlighter-rouge">-L/opt/local/lib -lpng16</code></p>
  </li>
</ol>

<p>With these information I can easily use the library with my project like: <br />
<code class="language-plaintext highlighter-rouge">gcc pngViewr.c -o pngViewr -I/opt/local/include/libpng16 -I/opt/local/include -L/opt/local/lib -lpng16</code></p>

<p>or even better: <br />
<code class="language-plaintext highlighter-rouge">gcc pngViewr.c -o pngViewr $(pkg-config --libs -cflags libpng)</code></p>]]></content><author><name></name></author><summary type="html"><![CDATA[pkg-config is a tool that originated in Linux to view the meta information about installed libraries. It can be used to know things like: include path of header files link path of library files version of library etc.]]></summary></entry><entry><title type="html">Git bisect</title><link href="/2024/08/01/Git-bisect.html" rel="alternate" type="text/html" title="Git bisect" /><published>2024-08-01T00:00:00-05:00</published><updated>2024-08-01T00:00:00-05:00</updated><id>/2024/08/01/Git-bisect</id><content type="html" xml:base="/2024/08/01/Git-bisect.html"><![CDATA[<p><a href="https://git-scm.com/docs/git-bisect">Git bisect</a> is a tool that does binary search in the git history between commits to locate the actual commit where the change of interest happen. This “change of interest” is usually a bug, so <code class="language-plaintext highlighter-rouge">git bisect bad</code> command is used to indicate observation of it.</p>

<h3 id="how-to-use">How to use?</h3>
<p>Basically we do manual binary search.</p>
<ul>
  <li>do <code class="language-plaintext highlighter-rouge">git bisect start</code> to start git bisect</li>
  <li>do <code class="language-plaintext highlighter-rouge">git bisect bad</code> to mark current commit as bad</li>
  <li>do <code class="language-plaintext highlighter-rouge">git bisect good &lt;&lt;commit_hash&gt;&gt;</code> to mark good commit</li>
  <li>do <code class="language-plaintext highlighter-rouge">git bisect</code> to bisect to a mid commit</li>
</ul>

<p>Before marking current commit as good or bad we check the “change of interest”.
This could be manual inspection, test run, performance logs, anything.</p>

<h2 id="when-to-use">When to use?</h2>
<p>Anytime you want to locate the actual commit that caused the change. The affect of change must be reproducible.</p>
<ul>
  <li>Where was the bug introduced?</li>
  <li>What exactly improved this performance?</li>
  <li>What change cause the test to start failing?</li>
  <li>etc. etc.</li>
</ul>

<h3 id="related">Related</h3>
<p><a href="https://research.swtch.com/bisect">Russ cox’s blog on “Hash-Based Bisect Debugging in Compilers and Runtimes”</a></p>]]></content><author><name></name></author><summary type="html"><![CDATA[Git bisect is a tool that does binary search in the git history between commits to locate the actual commit where the change of interest happen. This “change of interest” is usually a bug, so git bisect bad command is used to indicate observation of it.]]></summary></entry><entry><title type="html">My notes on Haskell</title><link href="/2024/08/01/My-notes-on-Haskell.html" rel="alternate" type="text/html" title="My notes on Haskell" /><published>2024-08-01T00:00:00-05:00</published><updated>2024-08-01T00:00:00-05:00</updated><id>/2024/08/01/My-notes-on-Haskell</id><content type="html" xml:base="/2024/08/01/My-notes-on-Haskell.html"><![CDATA[<h4 id="let-and-where">Let and where</h4>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>module Main where 

-- let 
diff :: Integer -&gt; Integer -&gt; Integer
diff a b = let firstSmall = a &lt; b 
               difference = a - b
              in 
                if firstSmall then - difference else difference


-- where 
diff2 :: Integer -&gt; Integer -&gt; Integer
diff2 a b = if firstSmall then - difference else difference
           where 
             firstSmall = a &lt; b
             difference = a - b



main :: IO ()
-- main = print (diff 3 2)
main = print (diff 2 3)
</code></pre></div></div>

<h4 id="haskell-has-no-loop">Haskell has no loop</h4>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>-- Recursion and guards
factorial :: Integer -&gt; Integer
factorial n
    | n &lt;= 1 = 1
    | otherwise = n * factorial (n - 1)


-- Tail recursive way
-- Note: tail recursive functions can be replaced by while loop thus avoiding potential stackoverflow
fact :: Integer -&gt; Integer
fact n = accumulator n 1 
        where 
            accumulator n total 
                | n &lt;= 1 = total 
                | otherwise = accumulator (n-1) (n * total)
</code></pre></div></div>

<h4 id="parametric-polymorphism--list-comprehension">Parametric polymorphism &amp; list comprehension</h4>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>-- Cross product of lists with generic datatype
cross :: [a] -&gt; [b] -&gt; [(a, b)]
cross x y = [(i, j) | i &lt;- x, j &lt;- y]


-- Remove duplicates from the list
-- Parametric datatype a with Eq typeclass constraint
existsIn :: (Eq a) =&gt; a -&gt; [a] -&gt; Bool
existsIn _ [] = False 
existsIn a (x:xs) = (a == x) || (a `existsIn` xs)

removeDuplicates :: (Eq a) =&gt; [a] -&gt; [a]
removeDuplicates [] = []
removeDuplicates (x:xs)
    | x `existsIn` xs = removeDuplicates xs
    | otherwise = x : removeDuplicates xs
</code></pre></div></div>

<h4 id="challenge-graph-traversal">Challenge: graph traversal</h4>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>-- Create a function 'hasPath' that determines
-- if a path from one node to another exists in the directed graph.

-- Graph is a list of edges where edge is a pair of nodes which indicates 
-- and existence of path from the first to the second.
-- Eg. in a graph [(1,2), (2,3)], there are directed edges from 1 to 2 and 2 to 3

hasPath :: [(Int, Int)] -&gt; Int -&gt; Int -&gt; Bool
hasPath [] src dest = src == dest
hasPath xs src dest 
    | src == dest = True
    | otherwise = let connectingEdges = [(a,b) | (a,b) &lt;- xs, a /= src]
                  in or [hasPath connectingEdges b dest | (a, b) &lt;- xs, a == src]
</code></pre></div></div>

<h4 id="high-order-functions--lambda">High-order functions &amp; lambda</h4>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>filter (\(x,y) -&gt; x &gt; y) [(1,2), (2,3), (4,2), (2,1)]
map (\x -&gt; -x) [1,2,3]
foldl (\acc elem -&gt; acc + elem) 0 [1,2,3,4,5]
</code></pre></div></div>

<h4 id="currying--composition">Currying &amp; composition</h4>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>adder :: Int -&gt; Int -&gt; Int 
adder x y = x + y

-- composition of partial functions
result = adder 2 ((adder 2 . adder 1) 4)

-- dollar sign syntatic-sugar
result2 = adder 2 $ adder 2 . adder 1 $ 4
</code></pre></div></div>

<h4 id="challenge-find-prefixes">Challenge: find prefixes</h4>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>-- a function that returns all the prefixes of the list
-- eg: FindPrefixes [1,2,3] = [[1], [1,2], [1,2,3]]
findPrefixes :: [a] -&gt; [[a]]
findPrefixes = foldr (\x acc -&gt; [x] : (map (\sublst -&gt; x : sublst) acc)) []
</code></pre></div></div>

<h4 id="challenge-preorder-traversal-of-trie">Challenge: Preorder traversal of Trie</h4>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>module Main where 

data Trie a = Leaf a | Node a [Trie a]

preorderTraversal :: Trie a -&gt; [a]
preorderTraversal (Leaf a) = [a]
preorderTraversal (Node a children) = 
    a : foldl (\acc c -&gt; acc ++ preorderTraversal c) [] children

-- Trie
--   c
--   |-&gt; a
--   |   |-&gt;  r
--   |   |-&gt;  t
--   |-&gt; o
--       |-&gt;  o
--            |-&gt; l  

trie = Node 'c' [
    Node 'a' [
        Leaf 'r',
        Leaf 't'
    ],
    Node 'o' [
        Node 'o' [
            Leaf 'n'
        ]
    ]]

main :: IO ()
main = print $ preorderTraversal trie
</code></pre></div></div>

<h4 id="records">Records</h4>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>module Main where

data Person = Person { name :: String, age :: Int }

greet :: Person -&gt; [Char]
greet (Person name _) = "Hi, " ++ name

main :: IO ()
main = print $ greet Person { name = "Bipin", age = 23}
</code></pre></div></div>

<h4 id="typeclass-is-like-interface">Typeclass is like interface</h4>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>-- declaring typeclass
class Animal a where 
    canWalk :: a -&gt; Bool
    speak :: a -&gt; String

-- instance of typeclass for a type
data Dog = Dog { dogName :: String}
instance Animal Dog where 
    canWalk _ = True
    speak (Dog dogName) = "I am " ++ dogName ++ ". woof!!"

-- deriving typeclass Show (implemented based on type of fields)
data Crow = Crow { birdName :: String }
    deriving (Show)
instance Animal Crow where 
    canWalk _ = False
    speak (Crow birdName) = "I am " ++ birdName ++ ". Caw! Caw!" 

crow = Crow { birdName = "Mr. Crow"}

main :: IO ()
main = print $ show crow ++ " says " ++ speak crow
</code></pre></div></div>

<h4 id="io-action">IO Action</h4>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>-- IO action, not a function as it interacts with environment
-- do -&gt; for sequential step by step work
-- Evaluates to no expression so () type
main :: IO ()
main = do 
    inpt &lt;- getLine
    if inpt /= "exit" then do
        putStrLn $ "input: " ++ inpt
        main
    else 
        return ()
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>printInBetween :: [Int] -&gt; IO ()
printInBetween (x:[]) = return ()
printInBetween (x:y:[]) = do 
    putStrLn $ show x
    if x &lt; y then printInBetween $ (x+1) : [y]
    else return ()

main :: IO ()
main = do 
    putStrLn "Enter two integers separated by space."
    putStrLn "I will give you numbers in between."
    nums &lt;- getLine
    let numbers = map read $ words nums :: [Int]
    printInBetween numbers
</code></pre></div></div>

<h4 id="monad">Monad</h4>
<p>Monad is a box that can hold a value. It has a bind function (»=) that can be used to chain the monads together. When the value exists the bind function take the inner value and returns another monad. Otherwise it returns the fail case and the flow won’t go to the next item in the chain.</p>

<p>This is a very useful pattern to deal with exceptions, asynchronous operation eg. Promise, mutation of environment (IO actions), etc.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>module Main where 

import Control.Applicative
import Control.Monad (liftM, ap)

-- New Monad type
data MyMaybe a = Value a | NoValue
    deriving (Show)

-- This is needed for all monads 
instance Functor MyMaybe where
  fmap = liftM
instance Applicative MyMaybe where
  pure  = return
  (&lt;*&gt;) = ap

-- implementing Monad typeclass 
--    (&gt;&gt;=) is a bind function
instance Monad MyMaybe where 
    (&gt;&gt;=) :: MyMaybe a -&gt; (a -&gt; MyMaybe b) -&gt; MyMaybe b
    ma &gt;&gt;= func = case ma of
                    Value a -&gt; func a
                    NoValue -&gt; NoValue
    return a = Value a

-- example of chaining 
addMonads :: Num a =&gt; MyMaybe a -&gt; MyMaybe a -&gt; MyMaybe a
addMonads ma mb = ma &gt;&gt;= (\a -&gt; mb &gt;&gt;= (\b -&gt; return $ a + b))

-- do notation does the same but more readable
-- if at any point the value is NoValue 
--     the function returns immediately with NoValue
addMonads2 :: Num a =&gt; MyMaybe a -&gt; MyMaybe a -&gt; MyMaybe a
addMonads2 ma mb = do 
    a &lt;- ma
    b &lt;- mb
    return $ a + b

x = Value 12
y = Value 23

main :: IO ()
main = print $ addMonads2 x y
</code></pre></div></div>

<h4 id="functor-fmap-">Functor: fmap, &lt;$&gt;</h4>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>module Main where 

-- functor is a pattern with a function 
-- that maps the internal value without changing the structure
data Tree a = Leaf a | Node a (Tree a) (Tree a)
    deriving (Show)

instance Functor Tree where 
    fmap::(a-&gt;b) -&gt; Tree a -&gt; Tree b
    fmap func (Leaf a) = Leaf $ func a
    fmap func (Node a left right) = 
      Node (func a) (fmap func left) (fmap func right)

tree = Node 1 (Node 2 (Leaf 3) (Node 4 (Leaf 5) (Leaf 6))) (Leaf 7)
treeMapped = fmap (\x -&gt; -x) tree

-- &lt;$&gt; is a symbol for `fmap`
anotherMapped = (*(-10)) &lt;$&gt; tree

main :: IO ()
main = do
    print treeMapped 
    print anotherMapped

-- program output:
Node (-1) (Node (-2) (Leaf (-3)) (Node (-4) (Leaf (-5)) (Leaf (-6)))) (Leaf (-7))
Node (-10) (Node (-20) (Leaf (-30)) (Node (-40) (Leaf (-50)) (Leaf (-60)))) (Leaf (-70))
</code></pre></div></div>

<h4 id="applicative-functor--pure">Applicative Functor: &lt;*&gt;, pure</h4>

<p>Applicative is a typeclass the represents a function inside a container.  It provides a functions <code class="language-plaintext highlighter-rouge">pure</code> and <code class="language-plaintext highlighter-rouge">&lt;*&gt;</code>. <code class="language-plaintext highlighter-rouge">pure</code> takes a function and wraps around the container. <code class="language-plaintext highlighter-rouge">&lt;*&gt;</code> takes a Applicative and a value in a container and produces a container with a function applied to the value.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>module Main where

containerOfComputation:: Maybe (Integer -&gt; Integer)
containerOfComputation = Just (*2)

containerOfValue:: Maybe Integer
containerOfValue = Just 10

main :: IO()
main = print ()

-- program output
ghci&gt; containerOfComputation &lt;*&gt; containerOfValue
Just 20
ghci&gt; 
ghci&gt; Nothing &lt;*&gt; Just 2
Nothing
ghci&gt; Just (*2) &lt;*&gt; Nothing
Nothing
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>module Main where

add1 :: Integer -&gt; Integer -&gt; Integer
add1 x y = x + y

add2 :: Maybe (Integer -&gt; Integer -&gt; Integer)
add2 = Just add1

main :: IO ()
main = do 
    print $ add2 &lt;*&gt; Just 10 &lt;*&gt; Just 20
    -- "pure add" wraps the function in the container
    print $ pure add1 &lt;*&gt; Just 10 &lt;*&gt; Just 20

-- program output
Just 30
Just 30
</code></pre></div></div>
<h4 id="challenge-infinite-fibonacci-with-dp">Challenge: Infinite fibonacci with DP</h4>

<p>Haskell being a lazy language allows infinite data structures.</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>module Main where 

fibo = 0 : 1 : zipWith (+) fibo (tail fibo)

main :: IO ()
main = print $ take 10 fibo
</code></pre></div></div>

<h4 id="strictness-thunks-seq-deepseq">Strictness: thunks, seq, deepseq</h4>

<p>Haskell is a lazy language. It doesn’t execute the expression until it needs to. It keeps track of the unevaluated expressions as graph called thunks. Haskell function doesn’t evaluate the function parameters before applying the function. It creates a new expression (thunk) for the result of the function with the inputs which are other thunks (parameters). This is how the thunk graph is built. Since functions are pure in Haskell, the function expression is evaluated only once and the memoized result is shared. So the dependencies get merged into a single shared thunk thereby the evaluation tree gets converted into a directed graph with shared node. I.e thunk is a computation graph that is yet to be completely evaluated.</p>

<p>However, sometimes the thunk graph can build up and take huge memory and the performance is impacted due to this overhead. In such cases evaluating the thunk early can be desirable.</p>

<p>Haskell has a function called <code class="language-plaintext highlighter-rouge">seq:: a -&gt; b -&gt; b</code>. The behaviour of the function is enforced in Haskell compiler to evaluate <code class="language-plaintext highlighter-rouge">a</code> to <a href="https://wiki.haskell.org/Weak_head_normal_form">weak head normal form</a> before running <code class="language-plaintext highlighter-rouge">b</code>. In other words, <code class="language-plaintext highlighter-rouge">a</code> will be partially evaluated before running b. This provides a way of strictness in Haskell. Many common functions such as <code class="language-plaintext highlighter-rouge">foldl</code> have strict versions (<code class="language-plaintext highlighter-rouge">foldl'</code>) that use <code class="language-plaintext highlighter-rouge">seq</code> internally.</p>

<p>Haskell also provides a way to completely evaluate <code class="language-plaintext highlighter-rouge">a</code> before <code class="language-plaintext highlighter-rouge">b</code> called <code class="language-plaintext highlighter-rouge">deepseq</code>. It is in the module <code class="language-plaintext highlighter-rouge">Control.DeepSeq</code>. Complete evaluation of thunk is needed in situations such as when you are reading a file from the disk in an IO action. You want to get all contents from file, close the file and return contents from the IO action without keeping the unevaluated thunk with file cursor.</p>

<p>It is important to note that Haskell compiler can lose some type information on strict evaluation of thunk. Haskell compiler also does strictness analysis when the <code class="language-plaintext highlighter-rouge">-O</code> flag is set during compilation.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ghci&gt; x = [1..10] :: [Int]
ghci&gt; :sp x
x = _
ghci&gt; seq x ()
()
ghci&gt; :sp x
x = 1 : _
ghci&gt; 
ghci&gt; import Control.DeepSeq (deepseq)
ghci&gt; deepseq x ()
()
ghci&gt; :sp x
x = [1,2,3,4,5,6,7,8,9,10]
ghci&gt; 
</code></pre></div></div>

<h4 id="gadt">GADT</h4>
<p>Generalised Algebraic Datatype (GADT) is a language extension to Haskell that improves the normal Algebraic Datatype of Haskell by including type checking in the data constructor.</p>

<p>For example with a normal ADT:</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>data Expr = IntLit Int | 
             BoolLit Bool | 
             Add Expr Expr 
          deriving (Show)
          
main :: IO ()
main = do 
  print $ Add (BoolLit True) (IntLit 2)
</code></pre></div></div>

<p>Here we can create an expression that adds boolean and int literals. It would be nice to enforce the exact type of expression that could be added, and this is exactly what GADT provides.</p>

<p>With GADT:</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>{-# LANGUAGE GADTs #-}

data Expr a where
  IntLit :: Int -&gt; Expr Int
  BoolLit :: Bool -&gt; Expr Bool
  Add :: Expr Int -&gt; Expr Int -&gt; Expr Int
deriving instance (Show a) =&gt; Show (Expr a)
  
main :: IO()
main = do
  print $ Add (BoolLit True) (IntLit 2)
</code></pre></div></div>
<p>would give a compile time error as the Add expression can only work with two Int expressions.</p>

<h4 id="haskell-extensions">Haskell Extensions</h4>
<h5 id="type-family">Type Family</h5>
<p>Type family is similar to a function but it works on types instead of data. It allows us to associate many types with a common interface.</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>type family Bitsize a :: Nat

Explanation:
Bitsize is a type family that takes in a type 'a' and gives us a 'Nat' i.e Natual number type
</code></pre></div></div>]]></content><author><name></name></author><summary type="html"><![CDATA[Let and where ``` module Main where]]></summary></entry><entry><title type="html">Essense of Merkle tree</title><link href="/2020/01/21/Merkle-tree-in-2-minutes.html" rel="alternate" type="text/html" title="Essense of Merkle tree" /><published>2020-01-21T00:00:00-06:00</published><updated>2020-01-21T00:00:00-06:00</updated><id>/2020/01/21/Merkle-tree-in-2-minutes</id><content type="html" xml:base="/2020/01/21/Merkle-tree-in-2-minutes.html"><![CDATA[<p>To construct a Merkel Tree, we basically hash the individual data blocks and hash those hashes and hash those hashes and so on. Forming a tree structure.</p>

<p><img src="/assets/images/merkle_tree/merkle.png" alt="image" height="500px" /></p>

<p>While hashing the hashes say <strong>H1</strong>, <strong>H2</strong>, <strong>H3</strong> we append those hashes to get a single string <strong>H1 + H2 + H3</strong> and hash that individual string to get a new hash <strong>H123</strong>.</p>

<p>Merkle Tree is mainly used to efficiently verify the integrity of the data.</p>

<p>Let’s take a closer look at the diagram above: hash <strong>H12</strong> has basically the summary of <strong>data1</strong> and <strong>data2</strong>. Even if a single bit in <strong>data1</strong> or <strong>data2</strong> changes it will be reflected in <strong>H12</strong>. Thus, if we are comparing two Merkle trees and found that <strong>H12</strong> is the same in both. Then it guarantees that <strong>data1</strong> and <strong>data2</strong> haven’t been changed.</p>

<p>This way root of the tree holds the summary of all its children and we only need to compare the root node to detect the differences.</p>

<p>In order to identify the data nodes that have been changed. We can compare the root hashes. If that is different, we can compare the hashes of its children and so on.</p>

<p>Say, we were transferring the data from one server node to another. And in the meantime, <strong>data3</strong> got updated in the source.</p>

<p><img src="/assets/images/merkle_tree/merkle_update.png" alt="image" height="500px" /></p>

<p>Now on comparing the Merkle Tree of received data to its source. We can see that:</p>

<p><strong>H1234</strong> is different so there are changes. <strong>H12</strong> is the same so its sub-tree is clean. Following the hashes that are different, we go from <strong>H1234</strong> to <strong>H34</strong> to <strong>H3</strong> to <strong>data3</strong> basically identifying the changed data.</p>

<p>Merkel Tree has been useful in many use cases. DynamoDB uses Merkel Tree for consistent hashing. Git uses Merkel Tree to keep git history. It is also used in internet file sharing. Knowing the root hash from a trusted source we can combine only those data pieces that produce the same root hash allowing us to filter the tempered and infected data pieces.</p>

<p><em>Originally <a href="https://medium.com/@bipinoli90/merkle-tree-in-2-mins-simplified-1577d15b4850">published on Medium</a></em></p>]]></content><author><name></name></author><summary type="html"><![CDATA[To construct a Merkel Tree, we basically hash the individual data blocks and hash those hashes and hash those hashes and so on. Forming a tree structure.]]></summary></entry><entry><title type="html">Tic tac toe with minimax</title><link href="/2018/04/26/Tic-tac-toe-with-MiniMax-AI.html" rel="alternate" type="text/html" title="Tic tac toe with minimax" /><published>2018-04-26T00:00:00-05:00</published><updated>2018-04-26T00:00:00-05:00</updated><id>/2018/04/26/Tic-tac-toe-with-MiniMax-AI</id><content type="html" xml:base="/2018/04/26/Tic-tac-toe-with-MiniMax-AI.html"><![CDATA[<p><img src="/assets/images/tic_tac_toe/tic_tac_toe.png" alt="image" height="500px" /></p>

<p>With nothing particular to do, this semester break seemed pretty dull. I was lying in the bed bored and lazy. Suddenly, I had an urge to make a simple game. I decided on Tic Tac Toe as it seemed easy and started laying out my plan. Within few hours, I had some rudimentary game in front of me.</p>

<p>Github link: <a href="https://github.com/Bipinoli/Tic-Tac-Toe">here</a></p>

<p><em>Note: Later I made an android game from it in Godot and published the game on Google play store. The image above is the banner image from there. The game is no longer available in the store</em></p>

<p><em>Originally <a href="https://medium.com/@bipinoli90/tic-tac-toe-with-minimax-ai-102d19a8eb7b">published on Medium</a></em></p>]]></content><author><name></name></author><summary type="html"><![CDATA[]]></summary></entry></feed>